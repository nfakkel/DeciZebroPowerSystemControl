
LegTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c8c  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000d00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000284  00802000  00802000  00000d00  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d00  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d30  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002b0  00000000  00000000  00000d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000725a  00000000  00000000  00001020  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000363e  00000000  00000000  0000827a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001de2  00000000  00000000  0000b8b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006a4  00000000  00000000  0000d69c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003896  00000000  00000000  0000dd40  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001fee  00000000  00000000  000115d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000210  00000000  00000000  000135c4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
   8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
   c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  10:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  14:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  18:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  1c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  20:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  24:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  28:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  2c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  30:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  34:	0c 94 3d 02 	jmp	0x47a	; 0x47a <__vector_13>
  38:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  3c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  40:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  44:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  48:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  4c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  50:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  54:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  58:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  5c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  60:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  64:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  68:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  6c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  70:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  74:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  78:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  7c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  80:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  84:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  88:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  8c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  90:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  94:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  98:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  9c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  a0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  a4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  a8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  ac:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  b0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  b4:	0c 94 63 02 	jmp	0x4c6	; 0x4c6 <__vector_45>
  b8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  bc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  c0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  c4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  c8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  cc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  d0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  d4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  d8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  dc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  e0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  e4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  e8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  ec:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  f0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  f4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  f8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  fc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 100:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 104:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 108:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 10c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 110:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 114:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 118:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 11c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 120:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 124:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 128:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 12c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 130:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 134:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 138:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 13c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 140:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 144:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 148:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 14c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 150:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 154:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 158:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 15c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 160:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 164:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 168:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 16c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 170:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 174:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 178:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 17c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 180:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 184:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 188:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 18c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 190:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 194:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 198:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 19c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1a0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1a4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1a8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1ac:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1b0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1b4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1b8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1bc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1c0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1c4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1c8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1cc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1d0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1d4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1d8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1dc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1e0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1e4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1e8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1ec:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1f0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1f4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1f8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e2       	ldi	r29, 0x2F	; 47
 206:	de bf       	out	0x3e, r29	; 62

00000208 <__do_copy_data>:
 208:	10 e2       	ldi	r17, 0x20	; 32
 20a:	a0 e0       	ldi	r26, 0x00	; 0
 20c:	b0 e2       	ldi	r27, 0x20	; 32
 20e:	ec e8       	ldi	r30, 0x8C	; 140
 210:	fc e0       	ldi	r31, 0x0C	; 12
 212:	02 c0       	rjmp	.+4      	; 0x218 <__do_copy_data+0x10>
 214:	05 90       	lpm	r0, Z+
 216:	0d 92       	st	X+, r0
 218:	a0 30       	cpi	r26, 0x00	; 0
 21a:	b1 07       	cpc	r27, r17
 21c:	d9 f7       	brne	.-10     	; 0x214 <__do_copy_data+0xc>

0000021e <__do_clear_bss>:
 21e:	22 e2       	ldi	r18, 0x22	; 34
 220:	a0 e0       	ldi	r26, 0x00	; 0
 222:	b0 e2       	ldi	r27, 0x20	; 32
 224:	01 c0       	rjmp	.+2      	; 0x228 <.do_clear_bss_start>

00000226 <.do_clear_bss_loop>:
 226:	1d 92       	st	X+, r1

00000228 <.do_clear_bss_start>:
 228:	a4 38       	cpi	r26, 0x84	; 132
 22a:	b2 07       	cpc	r27, r18
 22c:	e1 f7       	brne	.-8      	; 0x226 <.do_clear_bss_loop>
 22e:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <main>
 232:	0c 94 44 06 	jmp	0xc88	; 0xc88 <_exit>

00000236 <__bad_interrupt>:
 236:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000023a <ADC_Wait_8MHz>:


//This function waits until the adc common mode is settled.

void ADC_Wait_8MHz(ADC_t * adc)
{
 23a:	fc 01       	movw	r30, r24
  	/* Store old prescaler value. */
  	uint8_t prescaler_val = adc->PRESCALER;
 23c:	84 81       	ldd	r24, Z+4	; 0x04

	/* Set prescaler value to minimum value. */
	adc->PRESCALER = ADC_PRESCALER_DIV4_gc;
 23e:	14 82       	std	Z+4, r1	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 240:	9a e2       	ldi	r25, 0x2A	; 42
 242:	9a 95       	dec	r25
 244:	f1 f7       	brne	.-4      	; 0x242 <ADC_Wait_8MHz+0x8>
 246:	00 c0       	rjmp	.+0      	; 0x248 <ADC_Wait_8MHz+0xe>

	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
	delay_us(4*COMMON_MODE_CYCLES);

	/* Set prescaler to old value*/
	adc->PRESCALER = prescaler_val;
 248:	84 83       	std	Z+4, r24	; 0x04
 24a:	08 95       	ret

0000024c <ReadCalibrationByte>:
uint8_t ReadCalibrationByte( uint8_t index ) //RECOMMENDED TO DISABLE INTERRUPTS WHILE DOING THIS
{
	uint8_t result;

	//set the flash command to reading factory data
	NVM_CMD = NVM_CMD_READ_CALIB_ROW_gc;
 24c:	aa ec       	ldi	r26, 0xCA	; 202
 24e:	b1 e0       	ldi	r27, 0x01	; 1
 250:	92 e0       	ldi	r25, 0x02	; 2
 252:	9c 93       	st	X, r25
	
	//read said factory data
	result = pgm_read_byte(index);
 254:	e8 2f       	mov	r30, r24
 256:	f0 e0       	ldi	r31, 0x00	; 0
 258:	84 91       	lpm	r24, Z

	//clear flash command
	NVM_CMD = NVM_CMD_NO_OPERATION_gc;
 25a:	1c 92       	st	X, r1

	return result;
}
 25c:	08 95       	ret

0000025e <adc_start>:

//aanroepen met ReadADC(&ADCA.CH0, offset, *aantal samples*) en returned dan uint16_t
// weet niet of ch0 werkt met pin A3

void adc_start(void)
{
 25e:	cf 93       	push	r28
 260:	df 93       	push	r29
	//set PA4/3/2 as output not needed, they're inputs 
	//PORTA.DIRSET |= 0b00011100;
	
	//load factory calibration bytes to ADC regs
	ADCA.CALL = ReadCalibrationByte(offsetof ( NVM_PROD_SIGNATURES_t , ADCACAL0 ) ) ;
 262:	80 e2       	ldi	r24, 0x20	; 32
 264:	0e 94 26 01 	call	0x24c	; 0x24c <ReadCalibrationByte>
 268:	c0 e0       	ldi	r28, 0x00	; 0
 26a:	d2 e0       	ldi	r29, 0x02	; 2
 26c:	8c 87       	std	Y+12, r24	; 0x0c
	ADCA.CALH = ReadCalibrationByte(offsetof ( NVM_PROD_SIGNATURES_t , ADCACAL1 ) ) ;
 26e:	81 e2       	ldi	r24, 0x21	; 33
 270:	0e 94 26 01 	call	0x24c	; 0x24c <ReadCalibrationByte>
 274:	8d 87       	std	Y+13, r24	; 0x0d
	
	//set 12-bit resolution and unsigned mode
	ADCA.CTRLB = (ADCA.CTRLB & ~(ADC_RESOLUTION_gm)) | (ADC_RESOLUTION_12BIT_gc);
 276:	89 81       	ldd	r24, Y+1	; 0x01
 278:	89 7f       	andi	r24, 0xF9	; 249
 27a:	89 83       	std	Y+1, r24	; 0x01
	
	//set reference voltage to intern Vcc/1.6
	ADCA.REFCTRL = ((ADCA.REFCTRL & ~(ADC_REFSEL_gm))|ADC_REFSEL_INTVCC_gc);
 27c:	8a 81       	ldd	r24, Y+2	; 0x02
 27e:	8f 78       	andi	r24, 0x8F	; 143
 280:	80 61       	ori	r24, 0x10	; 16
 282:	8a 83       	std	Y+2, r24	; 0x02
	
	//set prescaler to /8 -> 2MHz to 125kHz (can be adjusted)
	ADCA.PRESCALER = ((ADCA.PRESCALER & ~ADC_PRESCALER_gm) | ADC_PRESCALER_DIV8_gc);	
 284:	8c 81       	ldd	r24, Y+4	; 0x04
 286:	88 7f       	andi	r24, 0xF8	; 248
 288:	81 60       	ori	r24, 0x01	; 1
 28a:	8c 83       	std	Y+4, r24	; 0x04

	//set convmode to single ended and gain to 1x
	ADCA.CH0.CTRL = ((ADCA.CH0.CTRL & ~(ADC_CH_GAIN_gm |ADC_CH_INPUTMODE_gm))| (ADC_CH_GAIN_1X_gc|ADC_CH_INPUTMODE_SINGLEENDED_gc));
 28c:	88 a1       	ldd	r24, Y+32	; 0x20
 28e:	80 7e       	andi	r24, 0xE0	; 224
 290:	81 60       	ori	r24, 0x01	; 1
 292:	88 a3       	std	Y+32, r24	; 0x20
	ADCA.CH1.CTRL = ((ADCA.CH1.CTRL & ~(ADC_CH_GAIN_gm |ADC_CH_INPUTMODE_gm))| (ADC_CH_GAIN_1X_gc|ADC_CH_INPUTMODE_SINGLEENDED_gc));
 294:	88 a5       	ldd	r24, Y+40	; 0x28
 296:	80 7e       	andi	r24, 0xE0	; 224
 298:	81 60       	ori	r24, 0x01	; 1
 29a:	88 a7       	std	Y+40, r24	; 0x28
	ADCA.CH2.CTRL = ((ADCA.CH2.CTRL & ~(ADC_CH_GAIN_gm |ADC_CH_INPUTMODE_gm))| (ADC_CH_GAIN_1X_gc|ADC_CH_INPUTMODE_SINGLEENDED_gc));
 29c:	88 a9       	ldd	r24, Y+48	; 0x30
 29e:	80 7e       	andi	r24, 0xE0	; 224
 2a0:	81 60       	ori	r24, 0x01	; 1
 2a2:	88 ab       	std	Y+48, r24	; 0x30
//	ADCA.CH3.CTRL = ((ADCA.CH3.CTRL & ~(ADC_CH_GAIN_gm |ADC_CH_INPUTMODE_gm))| (ADC_CH_GAIN_1X_gc|ADC_CH_INPUTMODE_SINGLEENDED_gc));
	
	//set input mode to pin 4 when using signed
	ADCA.CH0.MUXCTRL = ((ADCA.CH0.MUXCTRL & ~ADC_CH_MUXPOS_gm )| ADC_CH_MUXPOS_PIN4_gc);
 2a4:	89 a1       	ldd	r24, Y+33	; 0x21
 2a6:	87 78       	andi	r24, 0x87	; 135
 2a8:	80 62       	ori	r24, 0x20	; 32
 2aa:	89 a3       	std	Y+33, r24	; 0x21
	ADCA.CH1.MUXCTRL = ((ADCA.CH1.MUXCTRL & ~ADC_CH_MUXPOS_gm )| ADC_CH_MUXPOS_PIN3_gc);
 2ac:	89 a5       	ldd	r24, Y+41	; 0x29
 2ae:	87 78       	andi	r24, 0x87	; 135
 2b0:	88 61       	ori	r24, 0x18	; 24
 2b2:	89 a7       	std	Y+41, r24	; 0x29
	ADCA.CH2.MUXCTRL = ((ADCA.CH2.MUXCTRL & ~ADC_CH_MUXPOS_gm )| ADC_CH_MUXPOS_PIN2_gc);
 2b4:	89 a9       	ldd	r24, Y+49	; 0x31
 2b6:	87 78       	andi	r24, 0x87	; 135
 2b8:	80 61       	ori	r24, 0x10	; 16
 2ba:	89 ab       	std	Y+49, r24	; 0x31
//	ADCA.CH3.MUXCTRL = ((ADCA.CH3.MUXCTRL & ~ADC_CH_MUXPOS_gm )| ADC_CH_MUXPOS_PIN1_gc);

	//enable adc
	ADCA.CTRLA |= ADC_ENABLE_bm;
 2bc:	88 81       	ld	r24, Y
 2be:	81 60       	ori	r24, 0x01	; 1
 2c0:	88 83       	st	Y, r24
	
  	/* Wait 4*COMMON_MODE_CYCLES for common mode to settle. */
  	ADC_Wait_8MHz(&ADCA) ;
 2c2:	80 e0       	ldi	r24, 0x00	; 0
 2c4:	92 e0       	ldi	r25, 0x02	; 2
 2c6:	0e 94 1d 01 	call	0x23a	; 0x23a <ADC_Wait_8MHz>
	//DMA.CH0.DESTADDR1 = (( (uint16_t) adc_buffer) >> 8) & 0xFF;
	//DMA.CH0.DESTADDR2 = 0;
	//DMA.CH0.SRCADDR0 = (( (uint16_t) &ADCA.CH0.RES) >> 0) & 0xFF;
	//DMA.CH0.SRCADDR1 = (( (uint16_t) &ADCA.CH0.RES) >> 8) & 0xFF;
	//DMA.CH0.SRCADDR2 = 0;
}
 2ca:	df 91       	pop	r29
 2cc:	cf 91       	pop	r28
 2ce:	08 95       	ret

000002d0 <error_init>:
uint8_t last_error = 0;
uint32_t errors_array[ERROR_SIZE];
//static int32_t emergency_stop = 0;

void error_init()
{
 2d0:	e6 e0       	ldi	r30, 0x06	; 6
 2d2:	f0 e2       	ldi	r31, 0x20	; 32
 2d4:	86 e4       	ldi	r24, 0x46	; 70
 2d6:	90 e2       	ldi	r25, 0x20	; 32
	for (uint32_t i = 0;i < ERROR_SIZE;i++)
	{
		errors_array[i] = 0;
 2d8:	11 92       	st	Z+, r1
 2da:	11 92       	st	Z+, r1
 2dc:	11 92       	st	Z+, r1
 2de:	11 92       	st	Z+, r1
uint32_t errors_array[ERROR_SIZE];
//static int32_t emergency_stop = 0;

void error_init()
{
	for (uint32_t i = 0;i < ERROR_SIZE;i++)
 2e0:	e8 17       	cp	r30, r24
 2e2:	f9 07       	cpc	r31, r25
 2e4:	c9 f7       	brne	.-14     	; 0x2d8 <error_init+0x8>
	{
		errors_array[i] = 0;
	}
}
 2e6:	08 95       	ret

000002e8 <error_report>:


void error_report(uint8_t error)
{
 2e8:	cf 93       	push	r28
 2ea:	c8 2f       	mov	r28, r24
	 * BEGIN critical section
	 */
	//cli();

	/* check what errors where already reported */
	if(errors_array[error - 1] == 0){
 2ec:	90 e0       	ldi	r25, 0x00	; 0
 2ee:	01 97       	sbiw	r24, 0x01	; 1
 2f0:	fc 01       	movw	r30, r24
 2f2:	ee 0f       	add	r30, r30
 2f4:	ff 1f       	adc	r31, r31
 2f6:	ee 0f       	add	r30, r30
 2f8:	ff 1f       	adc	r31, r31
 2fa:	ea 5f       	subi	r30, 0xFA	; 250
 2fc:	ff 4d       	sbci	r31, 0xDF	; 223
 2fe:	40 81       	ld	r20, Z
 300:	51 81       	ldd	r21, Z+1	; 0x01
 302:	62 81       	ldd	r22, Z+2	; 0x02
 304:	73 81       	ldd	r23, Z+3	; 0x03
 306:	45 2b       	or	r20, r21
 308:	46 2b       	or	r20, r22
 30a:	47 2b       	or	r20, r23
 30c:	29 f4       	brne	.+10     	; 0x318 <error_report+0x30>
		error_counter++;
 30e:	20 91 01 20 	lds	r18, 0x2001	; 0x802001 <error_counter>
 312:	2f 5f       	subi	r18, 0xFF	; 255
 314:	20 93 01 20 	sts	0x2001, r18	; 0x802001 <error_counter>
	}
	errors_array[error - 1] = 1;
 318:	88 0f       	add	r24, r24
 31a:	99 1f       	adc	r25, r25
 31c:	88 0f       	add	r24, r24
 31e:	99 1f       	adc	r25, r25
 320:	fc 01       	movw	r30, r24
 322:	ea 5f       	subi	r30, 0xFA	; 250
 324:	ff 4d       	sbci	r31, 0xDF	; 223
 326:	81 e0       	ldi	r24, 0x01	; 1
 328:	90 e0       	ldi	r25, 0x00	; 0
 32a:	a0 e0       	ldi	r26, 0x00	; 0
 32c:	b0 e0       	ldi	r27, 0x00	; 0
 32e:	80 83       	st	Z, r24
 330:	91 83       	std	Z+1, r25	; 0x01
 332:	a2 83       	std	Z+2, r26	; 0x02
 334:	b3 83       	std	Z+3, r27	; 0x03

	last_error = error;
 336:	c0 93 00 20 	sts	0x2000, r28	; 0x802000 <__data_end>

	vregs_write(VREGS_ERROR_COUNTER, error_counter);
 33a:	40 91 01 20 	lds	r20, 0x2001	; 0x802001 <error_counter>
 33e:	63 e1       	ldi	r22, 0x13	; 19
 340:	70 e0       	ldi	r23, 0x00	; 0
 342:	80 e0       	ldi	r24, 0x00	; 0
 344:	90 e0       	ldi	r25, 0x00	; 0
 346:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
	vregs_write(VREGS_LAST_ERROR, error);
 34a:	4c 2f       	mov	r20, r28
 34c:	64 e1       	ldi	r22, 0x14	; 20
 34e:	70 e0       	ldi	r23, 0x00	; 0
 350:	80 e0       	ldi	r24, 0x00	; 0
 352:	90 e0       	ldi	r25, 0x00	; 0
 354:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>

	//sei();
	/**
	 * END critical section
	 */
}
 358:	cf 91       	pop	r28
 35a:	08 95       	ret

0000035c <TWIE_SlaveProcessData>:
int8_t offset;
int8_t power = 0;
int8_t count = 0;

void TWIE_SlaveProcessData(void)
{
 35c:	ef 92       	push	r14
 35e:	ff 92       	push	r15
 360:	1f 93       	push	r17
 362:	cf 93       	push	r28
 364:	df 93       	push	r29
	uint8_t bufIndex = twiSlave.receivedData[0];
 366:	0f 2e       	mov	r0, r31
 368:	ff e5       	ldi	r31, 0x5F	; 95
 36a:	ef 2e       	mov	r14, r31
 36c:	f0 e2       	ldi	r31, 0x20	; 32
 36e:	ff 2e       	mov	r15, r31
 370:	f0 2d       	mov	r31, r0
 372:	f7 01       	movw	r30, r14
 374:	d4 81       	ldd	r29, Z+4	; 0x04
	uint8_t bufSize = twiSlave.bytesReceived;
 376:	14 89       	ldd	r17, Z+20	; 0x14
	twiSlave.sendData[0] = vregs_read_buffer(bufIndex); //send the read data from register
 378:	6d 2f       	mov	r22, r29
 37a:	70 e0       	ldi	r23, 0x00	; 0
 37c:	80 e0       	ldi	r24, 0x00	; 0
 37e:	90 e0       	ldi	r25, 0x00	; 0
 380:	0e 94 b8 05 	call	0xb70	; 0xb70 <vregs_read_buffer>
 384:	f7 01       	movw	r30, r14
 386:	84 87       	std	Z+12, r24	; 0x0c
	twiSlave.sendData[1] = vregs_read_buffer(bufIndex+1);//send the read data from register+1 if word is requested
 388:	6d 2f       	mov	r22, r29
 38a:	70 e0       	ldi	r23, 0x00	; 0
 38c:	6f 5f       	subi	r22, 0xFF	; 255
 38e:	7f 4f       	sbci	r23, 0xFF	; 255
 390:	07 2e       	mov	r0, r23
 392:	00 0c       	add	r0, r0
 394:	88 0b       	sbc	r24, r24
 396:	99 0b       	sbc	r25, r25
 398:	0e 94 b8 05 	call	0xb70	; 0xb70 <vregs_read_buffer>
 39c:	f7 01       	movw	r30, r14
 39e:	85 87       	std	Z+13, r24	; 0x0d
	/*Suggestion for ZebroBus protocol to read all registers*/
	//for (uint8_t i=0;(bufIndex+i)<VREGS_FILE_TOTAL_SIZE;i++)
	//{	
	//	twiSlave.sendData[i] = rw_reg[bufIndex+i];
	//}
	for (uint8_t recvIndex = 0; recvIndex<bufSize; bufIndex++)
 3a0:	11 23       	and	r17, r17
 3a2:	81 f0       	breq	.+32     	; 0x3c4 <TWIE_SlaveProcessData+0x68>
 3a4:	c0 e0       	ldi	r28, 0x00	; 0
 3a6:	6d 2f       	mov	r22, r29
 3a8:	6c 0f       	add	r22, r28
	{
		recvIndex++;
 3aa:	cf 5f       	subi	r28, 0xFF	; 255
		vregs_write(bufIndex, twiSlave.receivedData[recvIndex]);
 3ac:	ec 2f       	mov	r30, r28
 3ae:	f0 e0       	ldi	r31, 0x00	; 0
 3b0:	e1 5a       	subi	r30, 0xA1	; 161
 3b2:	ff 4d       	sbci	r31, 0xDF	; 223
 3b4:	44 81       	ldd	r20, Z+4	; 0x04
 3b6:	70 e0       	ldi	r23, 0x00	; 0
 3b8:	80 e0       	ldi	r24, 0x00	; 0
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
	/*Suggestion for ZebroBus protocol to read all registers*/
	//for (uint8_t i=0;(bufIndex+i)<VREGS_FILE_TOTAL_SIZE;i++)
	//{	
	//	twiSlave.sendData[i] = rw_reg[bufIndex+i];
	//}
	for (uint8_t recvIndex = 0; recvIndex<bufSize; bufIndex++)
 3c0:	1c 13       	cpse	r17, r28
 3c2:	f1 cf       	rjmp	.-30     	; 0x3a6 <TWIE_SlaveProcessData+0x4a>
	{
		recvIndex++;
		vregs_write(bufIndex, twiSlave.receivedData[recvIndex]);
	}
}
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	1f 91       	pop	r17
 3ca:	ff 90       	pop	r15
 3cc:	ef 90       	pop	r14
 3ce:	08 95       	ret

000003d0 <main>:
	//uint8_t adc_h;
	//uint8_t adc_l;
	
//	uint8_t count=0;
	
	PORTR.DIRSET = PIN0_bm | PIN1_bm;
 3d0:	e0 ee       	ldi	r30, 0xE0	; 224
 3d2:	f7 e0       	ldi	r31, 0x07	; 7
 3d4:	83 e0       	ldi	r24, 0x03	; 3
 3d6:	81 83       	std	Z+1, r24	; 0x01
	PORTR.OUTSET |= PIN0_bm | PIN1_bm;
 3d8:	85 81       	ldd	r24, Z+5	; 0x05
 3da:	83 60       	ori	r24, 0x03	; 3
 3dc:	85 83       	std	Z+5, r24	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3de:	8f e4       	ldi	r24, 0x4F	; 79
 3e0:	93 ec       	ldi	r25, 0xC3	; 195
 3e2:	01 97       	sbiw	r24, 0x01	; 1
 3e4:	f1 f7       	brne	.-4      	; 0x3e2 <main+0x12>
 3e6:	00 c0       	rjmp	.+0      	; 0x3e8 <main+0x18>
 3e8:	00 00       	nop
	_delay_ms(100);        //Delay for 1000ms => 1 sec
	PORTR.OUTCLR |= PIN0_bm | PIN1_bm;
 3ea:	86 81       	ldd	r24, Z+6	; 0x06
 3ec:	83 60       	ori	r24, 0x03	; 3
 3ee:	86 83       	std	Z+6, r24	; 0x06
 3f0:	8f e4       	ldi	r24, 0x4F	; 79
 3f2:	93 ec       	ldi	r25, 0xC3	; 195
 3f4:	01 97       	sbiw	r24, 0x01	; 1
 3f6:	f1 f7       	brne	.-4      	; 0x3f4 <main+0x24>
 3f8:	00 c0       	rjmp	.+0      	; 0x3fa <main+0x2a>
 3fa:	00 00       	nop
	_delay_ms(100);
	sensor_init();
 3fc:	0e 94 a6 02 	call	0x54c	; 0x54c <sensor_init>
	
	/* Initialize TWI slave. */
	TWI_SlaveInitializeDriver(&twiSlave, &TWIE, TWIE_SlaveProcessData);
 400:	4e ea       	ldi	r20, 0xAE	; 174
 402:	51 e0       	ldi	r21, 0x01	; 1
 404:	60 ea       	ldi	r22, 0xA0	; 160
 406:	74 e0       	ldi	r23, 0x04	; 4
 408:	8f e5       	ldi	r24, 0x5F	; 95
 40a:	90 e2       	ldi	r25, 0x20	; 32
 40c:	0e 94 b4 04 	call	0x968	; 0x968 <TWI_SlaveInitializeDriver>
	TWI_SlaveInitializeModule(&twiSlave,0x60,TWI_SLAVE_INTLVL_LO_gc);
 410:	40 e4       	ldi	r20, 0x40	; 64
 412:	60 e6       	ldi	r22, 0x60	; 96
 414:	8f e5       	ldi	r24, 0x5F	; 95
 416:	90 e2       	ldi	r25, 0x20	; 32
 418:	0e 94 bf 04 	call	0x97e	; 0x97e <TWI_SlaveInitializeModule>
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
 41c:	e0 ea       	ldi	r30, 0xA0	; 160
 41e:	f0 e0       	ldi	r31, 0x00	; 0
 420:	82 81       	ldd	r24, Z+2	; 0x02
 422:	81 60       	ori	r24, 0x01	; 1
 424:	82 83       	std	Z+2, r24	; 0x02
	sei();
 426:	78 94       	sei
	//uint16_t value=0;
	vregs_init();
 428:	0e 94 18 06 	call	0xc30	; 0xc30 <vregs_init>
	error_init();
 42c:	0e 94 68 01 	call	0x2d0	; 0x2d0 <error_init>
	PWM_Enable();
 430:	0e 94 8e 02 	call	0x51c	; 0x51c <PWM_Enable>
	zebro_alert_init();
 434:	0e 94 3b 06 	call	0xc76	; 0xc76 <zebro_alert_init>
	mppt_init();
 438:	0e 94 89 02 	call	0x512	; 0x512 <mppt_init>
	adc_start();
 43c:	0e 94 2f 01 	call	0x25e	; 0x25e <adc_start>
//	ADC_init();
	//
	
	while (1)
	{
		PORTR.OUTSET |= PIN0_bm | PIN1_bm;
 440:	c0 ee       	ldi	r28, 0xE0	; 224
 442:	d7 e0       	ldi	r29, 0x07	; 7
 444:	8d 81       	ldd	r24, Y+5	; 0x05
 446:	83 60       	ori	r24, 0x03	; 3
 448:	8d 83       	std	Y+5, r24	; 0x05
 44a:	9f e3       	ldi	r25, 0x3F	; 63
 44c:	2d e0       	ldi	r18, 0x0D	; 13
 44e:	83 e0       	ldi	r24, 0x03	; 3
 450:	91 50       	subi	r25, 0x01	; 1
 452:	20 40       	sbci	r18, 0x00	; 0
 454:	80 40       	sbci	r24, 0x00	; 0
 456:	e1 f7       	brne	.-8      	; 0x450 <__LOCK_REGION_LENGTH__+0x50>
 458:	00 c0       	rjmp	.+0      	; 0x45a <__LOCK_REGION_LENGTH__+0x5a>
 45a:	00 00       	nop
		//adc_h = (uint8_t) (adc_value >> 8);
		//
		//vregs_write(VREGS_QI_POWER_LOW,adc_l);
		//vregs_write(VREGS_QI_POWER_HIGH,adc_h);
		//vregs_writeout();
		Read_Current_Registers();
 45c:	0e 94 5f 03 	call	0x6be	; 0x6be <Read_Current_Registers>
		      //Delay for 1000ms => 1 sec
//				DutyCycle = SetDutyCycle(DUTYCYCLE_MIN);
//				TCC0.CCDBUF = DutyCycle;
//		clear_zebro_alert();

		PORTR.OUTCLR |= PIN0_bm | PIN1_bm;
 460:	8e 81       	ldd	r24, Y+6	; 0x06
 462:	83 60       	ori	r24, 0x03	; 3
 464:	8e 83       	std	Y+6, r24	; 0x06
 466:	9f e3       	ldi	r25, 0x3F	; 63
 468:	2d e0       	ldi	r18, 0x0D	; 13
 46a:	83 e0       	ldi	r24, 0x03	; 3
 46c:	91 50       	subi	r25, 0x01	; 1
 46e:	20 40       	sbci	r18, 0x00	; 0
 470:	80 40       	sbci	r24, 0x00	; 0
 472:	e1 f7       	brne	.-8      	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
 474:	00 c0       	rjmp	.+0      	; 0x476 <__LOCK_REGION_LENGTH__+0x76>
 476:	00 00       	nop
 478:	e5 cf       	rjmp	.-54     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>

0000047a <__vector_13>:
		
	}
}

ISR(TWIC_TWIM_vect)
{
 47a:	1f 92       	push	r1
 47c:	0f 92       	push	r0
 47e:	0f b6       	in	r0, 0x3f	; 63
 480:	0f 92       	push	r0
 482:	11 24       	eor	r1, r1
 484:	2f 93       	push	r18
 486:	3f 93       	push	r19
 488:	4f 93       	push	r20
 48a:	5f 93       	push	r21
 48c:	6f 93       	push	r22
 48e:	7f 93       	push	r23
 490:	8f 93       	push	r24
 492:	9f 93       	push	r25
 494:	af 93       	push	r26
 496:	bf 93       	push	r27
 498:	ef 93       	push	r30
 49a:	ff 93       	push	r31
	TWI_MasterInterruptHandler(&twiMaster);
 49c:	86 e4       	ldi	r24, 0x46	; 70
 49e:	90 e2       	ldi	r25, 0x20	; 32
 4a0:	0e 94 9b 04 	call	0x936	; 0x936 <TWI_MasterInterruptHandler>
}
 4a4:	ff 91       	pop	r31
 4a6:	ef 91       	pop	r30
 4a8:	bf 91       	pop	r27
 4aa:	af 91       	pop	r26
 4ac:	9f 91       	pop	r25
 4ae:	8f 91       	pop	r24
 4b0:	7f 91       	pop	r23
 4b2:	6f 91       	pop	r22
 4b4:	5f 91       	pop	r21
 4b6:	4f 91       	pop	r20
 4b8:	3f 91       	pop	r19
 4ba:	2f 91       	pop	r18
 4bc:	0f 90       	pop	r0
 4be:	0f be       	out	0x3f, r0	; 63
 4c0:	0f 90       	pop	r0
 4c2:	1f 90       	pop	r1
 4c4:	18 95       	reti

000004c6 <__vector_45>:

/*! TWIC Slave Interrupt vector. */
ISR(TWIE_TWIS_vect)
{
 4c6:	1f 92       	push	r1
 4c8:	0f 92       	push	r0
 4ca:	0f b6       	in	r0, 0x3f	; 63
 4cc:	0f 92       	push	r0
 4ce:	11 24       	eor	r1, r1
 4d0:	2f 93       	push	r18
 4d2:	3f 93       	push	r19
 4d4:	4f 93       	push	r20
 4d6:	5f 93       	push	r21
 4d8:	6f 93       	push	r22
 4da:	7f 93       	push	r23
 4dc:	8f 93       	push	r24
 4de:	9f 93       	push	r25
 4e0:	af 93       	push	r26
 4e2:	bf 93       	push	r27
 4e4:	ef 93       	push	r30
 4e6:	ff 93       	push	r31
	TWI_SlaveInterruptHandler(&twiSlave);
 4e8:	8f e5       	ldi	r24, 0x5F	; 95
 4ea:	90 e2       	ldi	r25, 0x20	; 32
 4ec:	0e 94 76 05 	call	0xaec	; 0xaec <TWI_SlaveInterruptHandler>
}
 4f0:	ff 91       	pop	r31
 4f2:	ef 91       	pop	r30
 4f4:	bf 91       	pop	r27
 4f6:	af 91       	pop	r26
 4f8:	9f 91       	pop	r25
 4fa:	8f 91       	pop	r24
 4fc:	7f 91       	pop	r23
 4fe:	6f 91       	pop	r22
 500:	5f 91       	pop	r21
 502:	4f 91       	pop	r20
 504:	3f 91       	pop	r19
 506:	2f 91       	pop	r18
 508:	0f 90       	pop	r0
 50a:	0f be       	out	0x3f, r0	; 63
 50c:	0f 90       	pop	r0
 50e:	1f 90       	pop	r1
 510:	18 95       	reti

00000512 <mppt_init>:
#include "pwm.h"
# include "mppt.h"

void mppt_init(void)
{
	PowerOld = 0;
 512:	10 92 78 20 	sts	0x2078, r1	; 0x802078 <PowerOld>
	LastStep = RIGHT;
 516:	10 92 79 20 	sts	0x2079, r1	; 0x802079 <LastStep>
 51a:	08 95       	ret

0000051c <PWM_Enable>:

void PWM_Enable(void)
{
	//enable output on PC3
	//PORTC.REMAP &= PORT_TC0D_bm;
	PORTC.DIRSET |= PIN3_bm ;//| PIN7_bm;
 51c:	e0 e4       	ldi	r30, 0x40	; 64
 51e:	f6 e0       	ldi	r31, 0x06	; 6
 520:	81 81       	ldd	r24, Z+1	; 0x01
 522:	88 60       	ori	r24, 0x08	; 8
 524:	81 83       	std	Z+1, r24	; 0x01

	
	//set the period of the single slope pwm
	TCC0.PER = ( PWM_period & HiResMask ) ;
 526:	e0 e0       	ldi	r30, 0x00	; 0
 528:	f8 e0       	ldi	r31, 0x08	; 8
 52a:	8c ef       	ldi	r24, 0xFC	; 252
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	86 a3       	std	Z+38, r24	; 0x26
 530:	97 a3       	std	Z+39, r25	; 0x27

	//enable single slope pwm and compare capture channel a
	TCC0.CTRLB = (TCC0.CTRLB & ~TC0_WGMODE_gm) |TC_WGMODE_SS_gc | TC0_CCDEN_bm;
 532:	81 81       	ldd	r24, Z+1	; 0x01
 534:	88 77       	andi	r24, 0x78	; 120
 536:	83 68       	ori	r24, 0x83	; 131
 538:	81 83       	std	Z+1, r24	; 0x01
	
	//set clock
	TCC0.CTRLA = (TCC0.CTRLA & ~TC0_CLKSEL_gm ) |TC_CLKSEL_DIV1_gc;
 53a:	80 81       	ld	r24, Z
 53c:	80 7f       	andi	r24, 0xF0	; 240
 53e:	81 60       	ori	r24, 0x01	; 1
 540:	80 83       	st	Z, r24
	
	// Enable interrupts on CC channel A with HI priority
	//TCC0.INTCTRLB = ( uint8_t ) TC_CCAINTLVL_LO_gc ;
	
	// Set default dutycycle.
	TCC0.CCDBUF =  DUTYCYCLE_DEFAULT;
 542:	86 e9       	ldi	r24, 0x96	; 150
 544:	90 e0       	ldi	r25, 0x00	; 0
 546:	86 af       	std	Z+62, r24	; 0x3e
 548:	97 af       	std	Z+63, r25	; 0x3f
 54a:	08 95       	ret

0000054c <sensor_init>:
		while(twiMaster.status != TWIM_STATUS_READY) {}
		Check_And_Write_Battery_Registers(battery_register[RegPos],twiMaster.readData[0],twiMaster.readData[1]);
	}
	//update vregs
	vregs_writeout();
}
 54c:	25 e0       	ldi	r18, 0x05	; 5
 54e:	40 e4       	ldi	r20, 0x40	; 64
 550:	60 e8       	ldi	r22, 0x80	; 128
 552:	74 e0       	ldi	r23, 0x04	; 4
 554:	86 e4       	ldi	r24, 0x46	; 70
 556:	90 e2       	ldi	r25, 0x20	; 32
 558:	0e 94 d5 03 	call	0x7aa	; 0x7aa <TWI_MasterInit>
 55c:	08 95       	ret

0000055e <Check_And_Write_Current_Registers>:

void Check_And_Write_Current_Registers(uint8_t reg, uint8_t adr, uint8_t high_byte, uint8_t low_byte)
{
 55e:	cf 93       	push	r28
 560:	c4 2f       	mov	r28, r20
	switch(adr) {
 562:	61 34       	cpi	r22, 0x41	; 65
 564:	91 f1       	breq	.+100    	; 0x5ca <Check_And_Write_Current_Registers+0x6c>
 566:	18 f4       	brcc	.+6      	; 0x56e <Check_And_Write_Current_Registers+0x10>
 568:	60 34       	cpi	r22, 0x40	; 64
 56a:	41 f0       	breq	.+16     	; 0x57c <Check_And_Write_Current_Registers+0x1e>
 56c:	a3 c0       	rjmp	.+326    	; 0x6b4 <Check_And_Write_Current_Registers+0x156>
 56e:	62 34       	cpi	r22, 0x42	; 66
 570:	09 f4       	brne	.+2      	; 0x574 <Check_And_Write_Current_Registers+0x16>
 572:	79 c0       	rjmp	.+242    	; 0x666 <Check_And_Write_Current_Registers+0x108>
 574:	63 34       	cpi	r22, 0x43	; 67
 576:	09 f4       	brne	.+2      	; 0x57a <Check_And_Write_Current_Registers+0x1c>
 578:	4f c0       	rjmp	.+158    	; 0x618 <Check_And_Write_Current_Registers+0xba>
 57a:	9c c0       	rjmp	.+312    	; 0x6b4 <Check_And_Write_Current_Registers+0x156>
		case ADDRESS_CURRENT_SENS_BUS :
		switch(reg) {
 57c:	82 30       	cpi	r24, 0x02	; 2
 57e:	19 f0       	breq	.+6      	; 0x586 <Check_And_Write_Current_Registers+0x28>
 580:	84 30       	cpi	r24, 0x04	; 4
 582:	81 f0       	breq	.+32     	; 0x5a4 <Check_And_Write_Current_Registers+0x46>
 584:	1e c0       	rjmp	.+60     	; 0x5c2 <Check_And_Write_Current_Registers+0x64>
			case CUR_BUS_VOLTAGE_REG :
			vregs_write(VREGS_BUS_CURRENT_LOW, 5);
 586:	45 e0       	ldi	r20, 0x05	; 5
 588:	64 e2       	ldi	r22, 0x24	; 36
 58a:	70 e0       	ldi	r23, 0x00	; 0
 58c:	80 e0       	ldi	r24, 0x00	; 0
 58e:	90 e0       	ldi	r25, 0x00	; 0
 590:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			vregs_write(VREGS_BUS_CURRENT_HIGH, high_byte);
 594:	4c 2f       	mov	r20, r28
 596:	65 e2       	ldi	r22, 0x25	; 37
 598:	70 e0       	ldi	r23, 0x00	; 0
 59a:	80 e0       	ldi	r24, 0x00	; 0
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			break;
 5a2:	8b c0       	rjmp	.+278    	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
			case CUR_CURRENT_REG :
			vregs_write(VREGS_BUS_VOLTAGE_LOW, low_byte);
 5a4:	42 2f       	mov	r20, r18
 5a6:	6e e2       	ldi	r22, 0x2E	; 46
 5a8:	70 e0       	ldi	r23, 0x00	; 0
 5aa:	80 e0       	ldi	r24, 0x00	; 0
 5ac:	90 e0       	ldi	r25, 0x00	; 0
 5ae:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			vregs_write(VREGS_BUS_VOLTAGE_HIGH, high_byte);
 5b2:	4c 2f       	mov	r20, r28
 5b4:	6f e2       	ldi	r22, 0x2F	; 47
 5b6:	70 e0       	ldi	r23, 0x00	; 0
 5b8:	80 e0       	ldi	r24, 0x00	; 0
 5ba:	90 e0       	ldi	r25, 0x00	; 0
 5bc:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			break;
 5c0:	7c c0       	rjmp	.+248    	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
			default :
			error_report(ERROR_UNKNOWN);
 5c2:	80 e1       	ldi	r24, 0x10	; 16
 5c4:	0e 94 74 01 	call	0x2e8	; 0x2e8 <error_report>
 5c8:	78 c0       	rjmp	.+240    	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
		}
		break;
		case ADDRESS_CURRENT_SENS_5V :
		switch(reg) {
 5ca:	82 30       	cpi	r24, 0x02	; 2
 5cc:	19 f0       	breq	.+6      	; 0x5d4 <Check_And_Write_Current_Registers+0x76>
 5ce:	84 30       	cpi	r24, 0x04	; 4
 5d0:	81 f0       	breq	.+32     	; 0x5f2 <Check_And_Write_Current_Registers+0x94>
 5d2:	1e c0       	rjmp	.+60     	; 0x610 <Check_And_Write_Current_Registers+0xb2>
			case CUR_BUS_VOLTAGE_REG :
			vregs_write(VREGS_5V_CURRENT_LOW, low_byte);
 5d4:	42 2f       	mov	r20, r18
 5d6:	68 e2       	ldi	r22, 0x28	; 40
 5d8:	70 e0       	ldi	r23, 0x00	; 0
 5da:	80 e0       	ldi	r24, 0x00	; 0
 5dc:	90 e0       	ldi	r25, 0x00	; 0
 5de:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			vregs_write(VREGS_5V_CURRENT_HIGH, high_byte);
 5e2:	4c 2f       	mov	r20, r28
 5e4:	69 e2       	ldi	r22, 0x29	; 41
 5e6:	70 e0       	ldi	r23, 0x00	; 0
 5e8:	80 e0       	ldi	r24, 0x00	; 0
 5ea:	90 e0       	ldi	r25, 0x00	; 0
 5ec:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			break;
 5f0:	64 c0       	rjmp	.+200    	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
			case CUR_CURRENT_REG :
			vregs_write(VREGS_5V_VOLTAGE_LOW, low_byte);
 5f2:	42 2f       	mov	r20, r18
 5f4:	62 e3       	ldi	r22, 0x32	; 50
 5f6:	70 e0       	ldi	r23, 0x00	; 0
 5f8:	80 e0       	ldi	r24, 0x00	; 0
 5fa:	90 e0       	ldi	r25, 0x00	; 0
 5fc:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			vregs_write(VREGS_5V_VOLTAGE_HIGH, high_byte);
 600:	4c 2f       	mov	r20, r28
 602:	63 e3       	ldi	r22, 0x33	; 51
 604:	70 e0       	ldi	r23, 0x00	; 0
 606:	80 e0       	ldi	r24, 0x00	; 0
 608:	90 e0       	ldi	r25, 0x00	; 0
 60a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			break;
 60e:	55 c0       	rjmp	.+170    	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
			default :
			error_report(ERROR_UNKNOWN);
 610:	80 e1       	ldi	r24, 0x10	; 16
 612:	0e 94 74 01 	call	0x2e8	; 0x2e8 <error_report>
 616:	51 c0       	rjmp	.+162    	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
		}
		break;
		case ADDRESS_CURRENT_SENS_3V3 :
		switch(reg) {
 618:	82 30       	cpi	r24, 0x02	; 2
 61a:	19 f0       	breq	.+6      	; 0x622 <Check_And_Write_Current_Registers+0xc4>
 61c:	84 30       	cpi	r24, 0x04	; 4
 61e:	81 f0       	breq	.+32     	; 0x640 <Check_And_Write_Current_Registers+0xe2>
 620:	1e c0       	rjmp	.+60     	; 0x65e <Check_And_Write_Current_Registers+0x100>
			case CUR_BUS_VOLTAGE_REG :
			vregs_write(VREGS_3V3_CURRENT_LOW, low_byte);
 622:	42 2f       	mov	r20, r18
 624:	66 e2       	ldi	r22, 0x26	; 38
 626:	70 e0       	ldi	r23, 0x00	; 0
 628:	80 e0       	ldi	r24, 0x00	; 0
 62a:	90 e0       	ldi	r25, 0x00	; 0
 62c:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			vregs_write(VREGS_3V3_CURRENT_HIGH, high_byte);
 630:	4c 2f       	mov	r20, r28
 632:	67 e2       	ldi	r22, 0x27	; 39
 634:	70 e0       	ldi	r23, 0x00	; 0
 636:	80 e0       	ldi	r24, 0x00	; 0
 638:	90 e0       	ldi	r25, 0x00	; 0
 63a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			break;
 63e:	3d c0       	rjmp	.+122    	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
			case CUR_CURRENT_REG :
			vregs_write(VREGS_3V3_VOLTAGE_LOW, low_byte);
 640:	42 2f       	mov	r20, r18
 642:	60 e3       	ldi	r22, 0x30	; 48
 644:	70 e0       	ldi	r23, 0x00	; 0
 646:	80 e0       	ldi	r24, 0x00	; 0
 648:	90 e0       	ldi	r25, 0x00	; 0
 64a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			vregs_write(VREGS_3V3_VOLTAGE_HIGH, high_byte);
 64e:	4c 2f       	mov	r20, r28
 650:	61 e3       	ldi	r22, 0x31	; 49
 652:	70 e0       	ldi	r23, 0x00	; 0
 654:	80 e0       	ldi	r24, 0x00	; 0
 656:	90 e0       	ldi	r25, 0x00	; 0
 658:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			break;
 65c:	2e c0       	rjmp	.+92     	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
			default :
			error_report(ERROR_UNKNOWN);
 65e:	80 e1       	ldi	r24, 0x10	; 16
 660:	0e 94 74 01 	call	0x2e8	; 0x2e8 <error_report>
 664:	2a c0       	rjmp	.+84     	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
		}
		break;
		case ADDRESS_CURRENT_SENS_SOLAR :
		switch(reg) {
 666:	82 30       	cpi	r24, 0x02	; 2
 668:	19 f0       	breq	.+6      	; 0x670 <Check_And_Write_Current_Registers+0x112>
 66a:	84 30       	cpi	r24, 0x04	; 4
 66c:	81 f0       	breq	.+32     	; 0x68e <Check_And_Write_Current_Registers+0x130>
 66e:	1e c0       	rjmp	.+60     	; 0x6ac <Check_And_Write_Current_Registers+0x14e>
			case CUR_BUS_VOLTAGE_REG :
			vregs_write(VREGS_SOLAR_CURRENT_LOW, low_byte);
 670:	42 2f       	mov	r20, r18
 672:	60 e2       	ldi	r22, 0x20	; 32
 674:	70 e0       	ldi	r23, 0x00	; 0
 676:	80 e0       	ldi	r24, 0x00	; 0
 678:	90 e0       	ldi	r25, 0x00	; 0
 67a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			vregs_write(VREGS_SOLAR_CURRENT_HIGH, high_byte);
 67e:	4c 2f       	mov	r20, r28
 680:	61 e2       	ldi	r22, 0x21	; 33
 682:	70 e0       	ldi	r23, 0x00	; 0
 684:	80 e0       	ldi	r24, 0x00	; 0
 686:	90 e0       	ldi	r25, 0x00	; 0
 688:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			break;
 68c:	16 c0       	rjmp	.+44     	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
			case CUR_CURRENT_REG :
			vregs_write(VREGS_SOLAR_VOLTAGE_LOW, low_byte);
 68e:	42 2f       	mov	r20, r18
 690:	6a e2       	ldi	r22, 0x2A	; 42
 692:	70 e0       	ldi	r23, 0x00	; 0
 694:	80 e0       	ldi	r24, 0x00	; 0
 696:	90 e0       	ldi	r25, 0x00	; 0
 698:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			vregs_write(VREGS_SOLAR_VOLTAGE_HIGH, high_byte);
 69c:	4c 2f       	mov	r20, r28
 69e:	6b e2       	ldi	r22, 0x2B	; 43
 6a0:	70 e0       	ldi	r23, 0x00	; 0
 6a2:	80 e0       	ldi	r24, 0x00	; 0
 6a4:	90 e0       	ldi	r25, 0x00	; 0
 6a6:	0e 94 a5 05 	call	0xb4a	; 0xb4a <vregs_write>
			break;
 6aa:	07 c0       	rjmp	.+14     	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
			default :
			error_report(ERROR_UNKNOWN);
 6ac:	80 e1       	ldi	r24, 0x10	; 16
 6ae:	0e 94 74 01 	call	0x2e8	; 0x2e8 <error_report>
 6b2:	03 c0       	rjmp	.+6      	; 0x6ba <Check_And_Write_Current_Registers+0x15c>
		}
		break;
		default :
		error_report(ERROR_UNKNOWN);
 6b4:	80 e1       	ldi	r24, 0x10	; 16
 6b6:	0e 94 74 01 	call	0x2e8	; 0x2e8 <error_report>
	}
}
 6ba:	cf 91       	pop	r28
 6bc:	08 95       	ret

000006be <Read_Current_Registers>:

void Read_Current_Registers(void)
{
 6be:	2f 92       	push	r2
 6c0:	3f 92       	push	r3
 6c2:	4f 92       	push	r4
 6c4:	5f 92       	push	r5
 6c6:	6f 92       	push	r6
 6c8:	7f 92       	push	r7
 6ca:	8f 92       	push	r8
 6cc:	9f 92       	push	r9
 6ce:	af 92       	push	r10
 6d0:	bf 92       	push	r11
 6d2:	cf 92       	push	r12
 6d4:	df 92       	push	r13
 6d6:	ef 92       	push	r14
 6d8:	ff 92       	push	r15
 6da:	0f 93       	push	r16
 6dc:	1f 93       	push	r17
 6de:	cf 93       	push	r28
 6e0:	df 93       	push	r29
 6e2:	cd b7       	in	r28, 0x3d	; 61
 6e4:	de b7       	in	r29, 0x3e	; 62
 6e6:	26 97       	sbiw	r28, 0x06	; 6
 6e8:	cd bf       	out	0x3d, r28	; 61
 6ea:	de bf       	out	0x3e, r29	; 62
	uint8_t current_addresses[4] = {ADDRESS_CURRENT_SENS_BUS,ADDRESS_CURRENT_SENS_5V, ADDRESS_CURRENT_SENS_3V3, ADDRESS_CURRENT_SENS_SOLAR};
 6ec:	80 e4       	ldi	r24, 0x40	; 64
 6ee:	89 83       	std	Y+1, r24	; 0x01
 6f0:	81 e4       	ldi	r24, 0x41	; 65
 6f2:	8a 83       	std	Y+2, r24	; 0x02
 6f4:	83 e4       	ldi	r24, 0x43	; 67
 6f6:	8b 83       	std	Y+3, r24	; 0x03
 6f8:	82 e4       	ldi	r24, 0x42	; 66
 6fa:	8c 83       	std	Y+4, r24	; 0x04
	uint8_t current_register[2] = {CUR_BUS_VOLTAGE_REG, CUR_CURRENT_REG};
 6fc:	82 e0       	ldi	r24, 0x02	; 2
 6fe:	8d 83       	std	Y+5, r24	; 0x05
 700:	84 e0       	ldi	r24, 0x04	; 4
 702:	8e 83       	std	Y+6, r24	; 0x06
 704:	ce 01       	movw	r24, r28
 706:	01 96       	adiw	r24, 0x01	; 1
 708:	5c 01       	movw	r10, r24
 70a:	2e 01       	movw	r4, r28
 70c:	95 e0       	ldi	r25, 0x05	; 5
 70e:	49 0e       	add	r4, r25
 710:	51 1c       	adc	r5, r1
 712:	3e 01       	movw	r6, r28
 714:	e7 e0       	ldi	r30, 0x07	; 7
 716:	6e 0e       	add	r6, r30
 718:	71 1c       	adc	r7, r1
	//PORTR.OUTCLR |= PIN0_bm | PIN1_bm;
	for (uint8_t AdrPos = 0; AdrPos < 4; AdrPos++)
	{
		for (uint8_t RegPos = 0; RegPos < 2; RegPos++)
		{
			TWI_MasterWriteRead(&twiMaster, current_addresses[AdrPos], &current_register[RegPos], 1, 2);
 71a:	0f 2e       	mov	r0, r31
 71c:	f6 e4       	ldi	r31, 0x46	; 70
 71e:	ef 2e       	mov	r14, r31
 720:	f0 e2       	ldi	r31, 0x20	; 32
 722:	ff 2e       	mov	r15, r31
 724:	f0 2d       	mov	r31, r0
			while(twiMaster.status != TWIM_STATUS_READY) {}
 726:	2e 2c       	mov	r2, r14
 728:	3f 2c       	mov	r3, r15
 72a:	22 c0       	rjmp	.+68     	; 0x770 <Read_Current_Registers+0xb2>
	//PORTR.OUTCLR |= PIN0_bm | PIN1_bm;
	for (uint8_t AdrPos = 0; AdrPos < 4; AdrPos++)
	{
		for (uint8_t RegPos = 0; RegPos < 2; RegPos++)
		{
			TWI_MasterWriteRead(&twiMaster, current_addresses[AdrPos], &current_register[RegPos], 1, 2);
 72c:	46 01       	movw	r8, r12
 72e:	f5 01       	movw	r30, r10
 730:	10 81       	ld	r17, Z
 732:	02 e0       	ldi	r16, 0x02	; 2
 734:	21 e0       	ldi	r18, 0x01	; 1
 736:	a6 01       	movw	r20, r12
 738:	61 2f       	mov	r22, r17
 73a:	82 2d       	mov	r24, r2
 73c:	93 2d       	mov	r25, r3
 73e:	0e 94 e6 03 	call	0x7cc	; 0x7cc <TWI_MasterWriteRead>
			while(twiMaster.status != TWIM_STATUS_READY) {}
 742:	f7 01       	movw	r30, r14
 744:	87 89       	ldd	r24, Z+23	; 0x17
 746:	81 11       	cpse	r24, r1
 748:	fc cf       	rjmp	.-8      	; 0x742 <Read_Current_Registers+0x84>
			Check_And_Write_Current_Registers(current_register[RegPos],current_addresses[AdrPos],twiMaster.readData[0],twiMaster.readData[1]);
 74a:	24 85       	ldd	r18, Z+12	; 0x0c
 74c:	43 85       	ldd	r20, Z+11	; 0x0b
 74e:	ff ef       	ldi	r31, 0xFF	; 255
 750:	cf 1a       	sub	r12, r31
 752:	df 0a       	sbc	r13, r31
 754:	61 2f       	mov	r22, r17
 756:	f4 01       	movw	r30, r8
 758:	80 81       	ld	r24, Z
 75a:	0e 94 af 02 	call	0x55e	; 0x55e <Check_And_Write_Current_Registers>
	uint8_t current_addresses[4] = {ADDRESS_CURRENT_SENS_BUS,ADDRESS_CURRENT_SENS_5V, ADDRESS_CURRENT_SENS_3V3, ADDRESS_CURRENT_SENS_SOLAR};
	uint8_t current_register[2] = {CUR_BUS_VOLTAGE_REG, CUR_CURRENT_REG};
	//PORTR.OUTCLR |= PIN0_bm | PIN1_bm;
	for (uint8_t AdrPos = 0; AdrPos < 4; AdrPos++)
	{
		for (uint8_t RegPos = 0; RegPos < 2; RegPos++)
 75e:	6c 14       	cp	r6, r12
 760:	7d 04       	cpc	r7, r13
 762:	21 f7       	brne	.-56     	; 0x72c <Read_Current_Registers+0x6e>
 764:	ff ef       	ldi	r31, 0xFF	; 255
 766:	af 1a       	sub	r10, r31
 768:	bf 0a       	sbc	r11, r31
void Read_Current_Registers(void)
{
	uint8_t current_addresses[4] = {ADDRESS_CURRENT_SENS_BUS,ADDRESS_CURRENT_SENS_5V, ADDRESS_CURRENT_SENS_3V3, ADDRESS_CURRENT_SENS_SOLAR};
	uint8_t current_register[2] = {CUR_BUS_VOLTAGE_REG, CUR_CURRENT_REG};
	//PORTR.OUTCLR |= PIN0_bm | PIN1_bm;
	for (uint8_t AdrPos = 0; AdrPos < 4; AdrPos++)
 76a:	4a 14       	cp	r4, r10
 76c:	5b 04       	cpc	r5, r11
 76e:	29 f0       	breq	.+10     	; 0x77a <Read_Current_Registers+0xbc>
 770:	6e 01       	movw	r12, r28
 772:	85 e0       	ldi	r24, 0x05	; 5
 774:	c8 0e       	add	r12, r24
 776:	d1 1c       	adc	r13, r1
 778:	d9 cf       	rjmp	.-78     	; 0x72c <Read_Current_Registers+0x6e>
			Check_And_Write_Current_Registers(current_register[RegPos],current_addresses[AdrPos],twiMaster.readData[0],twiMaster.readData[1]);
		}
	}
	
	//update vregs
	vregs_writeout();
 77a:	0e 94 d4 05 	call	0xba8	; 0xba8 <vregs_writeout>
}
 77e:	26 96       	adiw	r28, 0x06	; 6
 780:	cd bf       	out	0x3d, r28	; 61
 782:	de bf       	out	0x3e, r29	; 62
 784:	df 91       	pop	r29
 786:	cf 91       	pop	r28
 788:	1f 91       	pop	r17
 78a:	0f 91       	pop	r16
 78c:	ff 90       	pop	r15
 78e:	ef 90       	pop	r14
 790:	df 90       	pop	r13
 792:	cf 90       	pop	r12
 794:	bf 90       	pop	r11
 796:	af 90       	pop	r10
 798:	9f 90       	pop	r9
 79a:	8f 90       	pop	r8
 79c:	7f 90       	pop	r7
 79e:	6f 90       	pop	r6
 7a0:	5f 90       	pop	r5
 7a2:	4f 90       	pop	r4
 7a4:	3f 90       	pop	r3
 7a6:	2f 90       	pop	r2
 7a8:	08 95       	ret

000007aa <TWI_MasterInit>:
                    uint8_t address,
                    uint8_t bytesToRead)
{
	bool twi_status = TWI_MasterWriteRead(twi, address, 0, 0, bytesToRead);
	return twi_status;
}
 7aa:	fc 01       	movw	r30, r24
 7ac:	60 83       	st	Z, r22
 7ae:	71 83       	std	Z+1, r23	; 0x01
 7b0:	48 63       	ori	r20, 0x38	; 56
 7b2:	db 01       	movw	r26, r22
 7b4:	11 96       	adiw	r26, 0x01	; 1
 7b6:	4c 93       	st	X, r20
 7b8:	a0 81       	ld	r26, Z
 7ba:	b1 81       	ldd	r27, Z+1	; 0x01
 7bc:	15 96       	adiw	r26, 0x05	; 5
 7be:	2c 93       	st	X, r18
 7c0:	01 90       	ld	r0, Z+
 7c2:	f0 81       	ld	r31, Z
 7c4:	e0 2d       	mov	r30, r0
 7c6:	81 e0       	ldi	r24, 0x01	; 1
 7c8:	84 83       	std	Z+4, r24	; 0x04
 7ca:	08 95       	ret

000007cc <TWI_MasterWriteRead>:
 7cc:	0f 93       	push	r16
 7ce:	cf 93       	push	r28
 7d0:	df 93       	push	r29
 7d2:	fc 01       	movw	r30, r24
 7d4:	29 30       	cpi	r18, 0x09	; 9
 7d6:	98 f5       	brcc	.+102    	; 0x83e <TWI_MasterWriteRead+0x72>
 7d8:	09 30       	cpi	r16, 0x09	; 9
 7da:	98 f5       	brcc	.+102    	; 0x842 <TWI_MasterWriteRead+0x76>
 7dc:	87 89       	ldd	r24, Z+23	; 0x17
 7de:	81 11       	cpse	r24, r1
 7e0:	32 c0       	rjmp	.+100    	; 0x846 <TWI_MasterWriteRead+0x7a>
 7e2:	81 e0       	ldi	r24, 0x01	; 1
 7e4:	87 8b       	std	Z+23, r24	; 0x17
 7e6:	10 8e       	std	Z+24, r1	; 0x18
 7e8:	66 0f       	add	r22, r22
 7ea:	62 83       	std	Z+2, r22	; 0x02
 7ec:	22 23       	and	r18, r18
 7ee:	69 f0       	breq	.+26     	; 0x80a <TWI_MasterWriteRead+0x3e>
 7f0:	a4 2f       	mov	r26, r20
 7f2:	b5 2f       	mov	r27, r21
 7f4:	40 e0       	ldi	r20, 0x00	; 0
 7f6:	50 e0       	ldi	r21, 0x00	; 0
 7f8:	8d 91       	ld	r24, X+
 7fa:	ef 01       	movw	r28, r30
 7fc:	c4 0f       	add	r28, r20
 7fe:	d5 1f       	adc	r29, r21
 800:	8b 83       	std	Y+3, r24	; 0x03
 802:	4f 5f       	subi	r20, 0xFF	; 255
 804:	5f 4f       	sbci	r21, 0xFF	; 255
 806:	42 17       	cp	r20, r18
 808:	b8 f3       	brcs	.-18     	; 0x7f8 <TWI_MasterWriteRead+0x2c>
 80a:	23 8b       	std	Z+19, r18	; 0x13
 80c:	04 8b       	std	Z+20, r16	; 0x14
 80e:	15 8a       	std	Z+21, r1	; 0x15
 810:	16 8a       	std	Z+22, r1	; 0x16
 812:	83 89       	ldd	r24, Z+19	; 0x13
 814:	88 23       	and	r24, r24
 816:	41 f0       	breq	.+16     	; 0x828 <TWI_MasterWriteRead+0x5c>
 818:	82 81       	ldd	r24, Z+2	; 0x02
 81a:	8e 7f       	andi	r24, 0xFE	; 254
 81c:	01 90       	ld	r0, Z+
 81e:	f0 81       	ld	r31, Z
 820:	e0 2d       	mov	r30, r0
 822:	86 83       	std	Z+6, r24	; 0x06
 824:	81 e0       	ldi	r24, 0x01	; 1
 826:	12 c0       	rjmp	.+36     	; 0x84c <TWI_MasterWriteRead+0x80>
 828:	84 89       	ldd	r24, Z+20	; 0x14
 82a:	88 23       	and	r24, r24
 82c:	71 f0       	breq	.+28     	; 0x84a <TWI_MasterWriteRead+0x7e>
 82e:	82 81       	ldd	r24, Z+2	; 0x02
 830:	81 60       	ori	r24, 0x01	; 1
 832:	01 90       	ld	r0, Z+
 834:	f0 81       	ld	r31, Z
 836:	e0 2d       	mov	r30, r0
 838:	86 83       	std	Z+6, r24	; 0x06
 83a:	81 e0       	ldi	r24, 0x01	; 1
 83c:	07 c0       	rjmp	.+14     	; 0x84c <TWI_MasterWriteRead+0x80>
 83e:	80 e0       	ldi	r24, 0x00	; 0
 840:	05 c0       	rjmp	.+10     	; 0x84c <TWI_MasterWriteRead+0x80>
 842:	80 e0       	ldi	r24, 0x00	; 0
 844:	03 c0       	rjmp	.+6      	; 0x84c <TWI_MasterWriteRead+0x80>
 846:	80 e0       	ldi	r24, 0x00	; 0
 848:	01 c0       	rjmp	.+2      	; 0x84c <TWI_MasterWriteRead+0x80>
 84a:	81 e0       	ldi	r24, 0x01	; 1
 84c:	df 91       	pop	r29
 84e:	cf 91       	pop	r28
 850:	0f 91       	pop	r16
 852:	08 95       	ret

00000854 <TWI_MasterArbitrationLostBusErrorHandler>:
 *  Handles TWI responses to lost arbitration and bus error.
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterArbitrationLostBusErrorHandler(TWI_Master_t *twi)
{
 854:	fc 01       	movw	r30, r24
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
 856:	a0 81       	ld	r26, Z
 858:	b1 81       	ldd	r27, Z+1	; 0x01
 85a:	14 96       	adiw	r26, 0x04	; 4
 85c:	9c 91       	ld	r25, X
 85e:	14 97       	sbiw	r26, 0x04	; 4

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
 860:	92 ff       	sbrs	r25, 2
 862:	03 c0       	rjmp	.+6      	; 0x86a <TWI_MasterArbitrationLostBusErrorHandler+0x16>
		twi->result = TWIM_RESULT_BUS_ERROR;
 864:	84 e0       	ldi	r24, 0x04	; 4
 866:	80 8f       	std	Z+24, r24	; 0x18
 868:	02 c0       	rjmp	.+4      	; 0x86e <TWI_MasterArbitrationLostBusErrorHandler+0x1a>
	}
	/* If arbitration lost. */
	else {
		twi->result = TWIM_RESULT_ARBITRATION_LOST;
 86a:	83 e0       	ldi	r24, 0x03	; 3
 86c:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Clear interrupt flag. */
	twi->interface->MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
 86e:	98 60       	ori	r25, 0x08	; 8
 870:	14 96       	adiw	r26, 0x04	; 4
 872:	9c 93       	st	X, r25

	twi->status = TWIM_STATUS_READY;
 874:	17 8a       	std	Z+23, r1	; 0x17
 876:	08 95       	ret

00000878 <TWI_MasterWriteHandler>:
 *  Handles TWI transactions (master write) and responses to (N)ACK.
 *
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterWriteHandler(TWI_Master_t *twi)
{
 878:	cf 93       	push	r28
 87a:	df 93       	push	r29
 87c:	fc 01       	movw	r30, r24
	/* Local variables used in if tests to avoid compiler warning. */
	uint8_t bytesToWrite  = twi->bytesToWrite;
 87e:	93 89       	ldd	r25, Z+19	; 0x13
	uint8_t bytesToRead   = twi->bytesToRead;
 880:	24 89       	ldd	r18, Z+20	; 0x14

	/* If NOT acknowledged (NACK) by slave cancel the transaction. */
	if (twi->interface->MASTER.STATUS & TWI_MASTER_RXACK_bm) {
 882:	a0 81       	ld	r26, Z
 884:	b1 81       	ldd	r27, Z+1	; 0x01
 886:	14 96       	adiw	r26, 0x04	; 4
 888:	8c 91       	ld	r24, X
 88a:	14 97       	sbiw	r26, 0x04	; 4
 88c:	84 ff       	sbrs	r24, 4
 88e:	07 c0       	rjmp	.+14     	; 0x89e <TWI_MasterWriteHandler+0x26>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
 890:	83 e0       	ldi	r24, 0x03	; 3
 892:	13 96       	adiw	r26, 0x03	; 3
 894:	8c 93       	st	X, r24
		twi->result = TWIM_RESULT_NACK_RECEIVED;
 896:	85 e0       	ldi	r24, 0x05	; 5
 898:	80 8f       	std	Z+24, r24	; 0x18
		twi->status = TWIM_STATUS_READY;
 89a:	17 8a       	std	Z+23, r1	; 0x17
 89c:	1c c0       	rjmp	.+56     	; 0x8d6 <TWI_MasterWriteHandler+0x5e>
	}

	/* If more bytes to write, send data. */
	else if (twi->bytesWritten < bytesToWrite) {
 89e:	85 89       	ldd	r24, Z+21	; 0x15
 8a0:	89 17       	cp	r24, r25
 8a2:	58 f4       	brcc	.+22     	; 0x8ba <TWI_MasterWriteHandler+0x42>
		uint8_t data = twi->writeData[twi->bytesWritten];
 8a4:	85 89       	ldd	r24, Z+21	; 0x15
 8a6:	ef 01       	movw	r28, r30
 8a8:	c8 0f       	add	r28, r24
 8aa:	d1 1d       	adc	r29, r1
 8ac:	8b 81       	ldd	r24, Y+3	; 0x03
		twi->interface->MASTER.DATA = data;
 8ae:	17 96       	adiw	r26, 0x07	; 7
 8b0:	8c 93       	st	X, r24
		++twi->bytesWritten;
 8b2:	85 89       	ldd	r24, Z+21	; 0x15
 8b4:	8f 5f       	subi	r24, 0xFF	; 255
 8b6:	85 8b       	std	Z+21, r24	; 0x15
 8b8:	0e c0       	rjmp	.+28     	; 0x8d6 <TWI_MasterWriteHandler+0x5e>
	}

	/* If bytes to read, send repeated START condition + Address +
	 * 'R/_W = 1'
	 */
	else if (twi->bytesRead < bytesToRead) {
 8ba:	86 89       	ldd	r24, Z+22	; 0x16
 8bc:	82 17       	cp	r24, r18
 8be:	28 f4       	brcc	.+10     	; 0x8ca <TWI_MasterWriteHandler+0x52>
		uint8_t readAddress = twi->address | 0x01;
 8c0:	82 81       	ldd	r24, Z+2	; 0x02
 8c2:	81 60       	ori	r24, 0x01	; 1
		twi->interface->MASTER.ADDR = readAddress;
 8c4:	16 96       	adiw	r26, 0x06	; 6
 8c6:	8c 93       	st	X, r24
 8c8:	06 c0       	rjmp	.+12     	; 0x8d6 <TWI_MasterWriteHandler+0x5e>
	}

	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
 8ca:	83 e0       	ldi	r24, 0x03	; 3
 8cc:	13 96       	adiw	r26, 0x03	; 3
 8ce:	8c 93       	st	X, r24
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
 8d0:	81 e0       	ldi	r24, 0x01	; 1
 8d2:	80 8f       	std	Z+24, r24	; 0x18
	twi->status = TWIM_STATUS_READY;
 8d4:	17 8a       	std	Z+23, r1	; 0x17
	/* If transaction finished, send STOP condition and set RESULT OK. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_OK);
	}
}
 8d6:	df 91       	pop	r29
 8d8:	cf 91       	pop	r28
 8da:	08 95       	ret

000008dc <TWI_MasterReadHandler>:
 *  reading bytes from the TWI slave.
 *
 *  \param twi The TWI_Master_t struct instance.
 */
void TWI_MasterReadHandler(TWI_Master_t *twi)
{
 8dc:	fc 01       	movw	r30, r24
	/* Fetch data if bytes to be read. */
	if (twi->bytesRead < TWIM_READ_BUFFER_SIZE) {
 8de:	86 89       	ldd	r24, Z+22	; 0x16
 8e0:	88 30       	cpi	r24, 0x08	; 8
 8e2:	70 f4       	brcc	.+28     	; 0x900 <TWI_MasterReadHandler+0x24>
		uint8_t data = twi->interface->MASTER.DATA;
 8e4:	a0 81       	ld	r26, Z
 8e6:	b1 81       	ldd	r27, Z+1	; 0x01
 8e8:	17 96       	adiw	r26, 0x07	; 7
 8ea:	8c 91       	ld	r24, X
		twi->readData[twi->bytesRead] = data;
 8ec:	96 89       	ldd	r25, Z+22	; 0x16
 8ee:	df 01       	movw	r26, r30
 8f0:	a9 0f       	add	r26, r25
 8f2:	b1 1d       	adc	r27, r1
 8f4:	1b 96       	adiw	r26, 0x0b	; 11
 8f6:	8c 93       	st	X, r24
		twi->bytesRead++;
 8f8:	86 89       	ldd	r24, Z+22	; 0x16
 8fa:	8f 5f       	subi	r24, 0xFF	; 255
 8fc:	86 8b       	std	Z+22, r24	; 0x16
 8fe:	08 c0       	rjmp	.+16     	; 0x910 <TWI_MasterReadHandler+0x34>
	}

	/* If buffer overflow, issue STOP and BUFFER_OVERFLOW condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
 900:	a0 81       	ld	r26, Z
 902:	b1 81       	ldd	r27, Z+1	; 0x01
 904:	83 e0       	ldi	r24, 0x03	; 3
 906:	13 96       	adiw	r26, 0x03	; 3
 908:	8c 93       	st	X, r24
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
 90a:	82 e0       	ldi	r24, 0x02	; 2
 90c:	80 8f       	std	Z+24, r24	; 0x18
	twi->status = TWIM_STATUS_READY;
 90e:	17 8a       	std	Z+23, r1	; 0x17
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_STOP_gc;
		TWI_MasterTransactionFinished(twi, TWIM_RESULT_BUFFER_OVERFLOW);
	}

	/* Local variable used in if test to avoid compiler warning. */
	uint8_t bytesToRead = twi->bytesToRead;
 910:	94 89       	ldd	r25, Z+20	; 0x14

	/* If more bytes to read, issue ACK and start a byte read. */
	if (twi->bytesRead < bytesToRead) {
 912:	86 89       	ldd	r24, Z+22	; 0x16
 914:	89 17       	cp	r24, r25
 916:	30 f4       	brcc	.+12     	; 0x924 <TWI_MasterReadHandler+0x48>
		twi->interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
 918:	01 90       	ld	r0, Z+
 91a:	f0 81       	ld	r31, Z
 91c:	e0 2d       	mov	r30, r0
 91e:	82 e0       	ldi	r24, 0x02	; 2
 920:	83 83       	std	Z+3, r24	; 0x03
 922:	08 95       	ret
	}

	/* If transaction finished, issue NACK and STOP condition. */
	else {
		twi->interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm |
 924:	a0 81       	ld	r26, Z
 926:	b1 81       	ldd	r27, Z+1	; 0x01
 928:	87 e0       	ldi	r24, 0x07	; 7
 92a:	13 96       	adiw	r26, 0x03	; 3
 92c:	8c 93       	st	X, r24
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
 92e:	81 e0       	ldi	r24, 0x01	; 1
 930:	80 8f       	std	Z+24, r24	; 0x18
	twi->status = TWIM_STATUS_READY;
 932:	17 8a       	std	Z+23, r1	; 0x17
 934:	08 95       	ret

00000936 <TWI_MasterInterruptHandler>:
 *
 *  \param twi  The TWI_Master_t struct instance.
 */
void TWI_MasterInterruptHandler(TWI_Master_t *twi)
{
	uint8_t currentStatus = twi->interface->MASTER.STATUS;
 936:	dc 01       	movw	r26, r24
 938:	ed 91       	ld	r30, X+
 93a:	fc 91       	ld	r31, X
 93c:	24 81       	ldd	r18, Z+4	; 0x04

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
 93e:	32 2f       	mov	r19, r18
 940:	3c 70       	andi	r19, 0x0C	; 12
 942:	19 f0       	breq	.+6      	; 0x94a <TWI_MasterInterruptHandler+0x14>
	    (currentStatus & TWI_MASTER_BUSERR_bm)) {

		TWI_MasterArbitrationLostBusErrorHandler(twi);
 944:	0e 94 2a 04 	call	0x854	; 0x854 <TWI_MasterArbitrationLostBusErrorHandler>
 948:	08 95       	ret
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
 94a:	26 ff       	sbrs	r18, 6
 94c:	03 c0       	rjmp	.+6      	; 0x954 <TWI_MasterInterruptHandler+0x1e>
		TWI_MasterWriteHandler(twi);
 94e:	0e 94 3c 04 	call	0x878	; 0x878 <TWI_MasterWriteHandler>
 952:	08 95       	ret
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
 954:	22 23       	and	r18, r18
 956:	1c f4       	brge	.+6      	; 0x95e <TWI_MasterInterruptHandler+0x28>
		TWI_MasterReadHandler(twi);
 958:	0e 94 6e 04 	call	0x8dc	; 0x8dc <TWI_MasterReadHandler>
 95c:	08 95       	ret
 *  \param twi     The TWI_Master_t struct instance.
 *  \param result  The result of the operation.
 */
void TWI_MasterTransactionFinished(TWI_Master_t *twi, uint8_t result)
{
	twi->result = result;
 95e:	26 e0       	ldi	r18, 0x06	; 6
 960:	fc 01       	movw	r30, r24
 962:	20 8f       	std	Z+24, r18	; 0x18
	twi->status = TWIM_STATUS_READY;
 964:	17 8a       	std	Z+23, r1	; 0x17
 966:	08 95       	ret

00000968 <TWI_SlaveInitializeDriver>:
 *  \param processDataFunction  Pointer to the function that handles incoming data.
 */
void TWI_SlaveInitializeDriver(TWI_Slave_t *twi,
                               TWI_t *module,
                               void (*processDataFunction) (void))
{
 968:	fc 01       	movw	r30, r24
	twi->interface = module;
 96a:	60 83       	st	Z, r22
 96c:	71 83       	std	Z+1, r23	; 0x01
	twi->Process_Data = processDataFunction;
 96e:	42 83       	std	Z+2, r20	; 0x02
 970:	53 83       	std	Z+3, r21	; 0x03
	twi->bytesReceived = 0;
 972:	14 8a       	std	Z+20, r1	; 0x14
	twi->bytesSent = 0;
 974:	15 8a       	std	Z+21, r1	; 0x15
	twi->status = TWIS_STATUS_READY;
 976:	16 8a       	std	Z+22, r1	; 0x16
	twi->result = TWIS_RESULT_UNKNOWN;
 978:	17 8a       	std	Z+23, r1	; 0x17
	twi->abort = false;
 97a:	10 8e       	std	Z+24, r1	; 0x18
 97c:	08 95       	ret

0000097e <TWI_SlaveInitializeModule>:
 */
void TWI_SlaveInitializeModule(TWI_Slave_t *twi,
                               uint8_t address,
                               TWI_SLAVE_INTLVL_t intLevel)
{
	twi->interface->SLAVE.CTRLA = intLevel |
 97e:	dc 01       	movw	r26, r24
 980:	ed 91       	ld	r30, X+
 982:	fc 91       	ld	r31, X
 984:	11 97       	sbiw	r26, 0x01	; 1
 986:	48 63       	ori	r20, 0x38	; 56
 988:	40 87       	std	Z+8, r20	; 0x08
	                              TWI_SLAVE_DIEN_bm |
	                              TWI_SLAVE_APIEN_bm |
	                              TWI_SLAVE_ENABLE_bm;
	twi->interface->SLAVE.ADDR = (address<<1);
 98a:	ed 91       	ld	r30, X+
 98c:	fc 91       	ld	r31, X
 98e:	66 0f       	add	r22, r22
 990:	63 87       	std	Z+11, r22	; 0x0b
 992:	08 95       	ret

00000994 <TWI_SlaveAddressMatchHandler>:
 *  Prepares TWI module for transaction when an address match occures.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveAddressMatchHandler(TWI_Slave_t *twi)
{
 994:	fc 01       	movw	r30, r24
	/* If application signalling need to abort (error occured). */
	if (twi->abort) {
 996:	80 8d       	ldd	r24, Z+24	; 0x18
 998:	88 23       	and	r24, r24
 99a:	51 f0       	breq	.+20     	; 0x9b0 <TWI_SlaveAddressMatchHandler+0x1c>
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
 99c:	a0 81       	ld	r26, Z
 99e:	b1 81       	ldd	r27, Z+1	; 0x01
 9a0:	82 e0       	ldi	r24, 0x02	; 2
 9a2:	19 96       	adiw	r26, 0x09	; 9
 9a4:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 9a6:	86 e0       	ldi	r24, 0x06	; 6
 9a8:	87 8b       	std	Z+23, r24	; 0x17
	twi->status = TWIS_STATUS_READY;
 9aa:	16 8a       	std	Z+22, r1	; 0x16
{
	/* If application signalling need to abort (error occured). */
	if (twi->abort) {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
		twi->abort = false;
 9ac:	10 8e       	std	Z+24, r1	; 0x18
 9ae:	08 95       	ret
	} else {
		twi->status = TWIS_STATUS_BUSY;
 9b0:	81 e0       	ldi	r24, 0x01	; 1
 9b2:	86 8b       	std	Z+22, r24	; 0x16
		twi->result = TWIS_RESULT_UNKNOWN;
 9b4:	17 8a       	std	Z+23, r1	; 0x17

		/* Disable stop interrupt. */
		uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
 9b6:	a0 81       	ld	r26, Z
 9b8:	b1 81       	ldd	r27, Z+1	; 0x01
 9ba:	18 96       	adiw	r26, 0x08	; 8
 9bc:	8c 91       	ld	r24, X
 9be:	18 97       	sbiw	r26, 0x08	; 8
		twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
 9c0:	8b 7f       	andi	r24, 0xFB	; 251
 9c2:	18 96       	adiw	r26, 0x08	; 8
 9c4:	8c 93       	st	X, r24

		twi->bytesReceived = 0;
 9c6:	14 8a       	std	Z+20, r1	; 0x14
		twi->bytesSent = 0;
 9c8:	15 8a       	std	Z+21, r1	; 0x15

		/* Send ACK, wait for data interrupt. */
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
 9ca:	01 90       	ld	r0, Z+
 9cc:	f0 81       	ld	r31, Z
 9ce:	e0 2d       	mov	r30, r0
 9d0:	83 e0       	ldi	r24, 0x03	; 3
 9d2:	81 87       	std	Z+9, r24	; 0x09
 9d4:	08 95       	ret

000009d6 <TWI_SlaveStopHandler>:
/*! \brief TWI stop condition interrupt handler.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveStopHandler(TWI_Slave_t *twi)
{
 9d6:	fc 01       	movw	r30, r24
	/* Disable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
 9d8:	a0 81       	ld	r26, Z
 9da:	b1 81       	ldd	r27, Z+1	; 0x01
 9dc:	18 96       	adiw	r26, 0x08	; 8
 9de:	8c 91       	ld	r24, X
 9e0:	18 97       	sbiw	r26, 0x08	; 8
	twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
 9e2:	8b 7f       	andi	r24, 0xFB	; 251
 9e4:	18 96       	adiw	r26, 0x08	; 8
 9e6:	8c 93       	st	X, r24
	
	/* Clear APIF, according to flowchart don't ACK or NACK */
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
 9e8:	a0 81       	ld	r26, Z
 9ea:	b1 81       	ldd	r27, Z+1	; 0x01
 9ec:	1a 96       	adiw	r26, 0x0a	; 10
 9ee:	8c 91       	ld	r24, X
 9f0:	1a 97       	sbiw	r26, 0x0a	; 10
	twi->interface->SLAVE.STATUS = currentStatus | TWI_SLAVE_APIF_bm;
 9f2:	80 64       	ori	r24, 0x40	; 64
 9f4:	1a 96       	adiw	r26, 0x0a	; 10
 9f6:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 9f8:	81 e0       	ldi	r24, 0x01	; 1
 9fa:	87 8b       	std	Z+23, r24	; 0x17
	twi->status = TWIS_STATUS_READY;
 9fc:	16 8a       	std	Z+22, r1	; 0x16
 9fe:	08 95       	ret

00000a00 <TWI_SlaveReadHandler>:
 *  Handles TWI slave read transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveReadHandler(TWI_Slave_t *twi)
{
 a00:	cf 93       	push	r28
 a02:	df 93       	push	r29
 a04:	fc 01       	movw	r30, r24
	/* Enable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
 a06:	a0 81       	ld	r26, Z
 a08:	b1 81       	ldd	r27, Z+1	; 0x01
 a0a:	18 96       	adiw	r26, 0x08	; 8
 a0c:	8c 91       	ld	r24, X
 a0e:	18 97       	sbiw	r26, 0x08	; 8
	twi->interface->SLAVE.CTRLA = currentCtrlA | TWI_SLAVE_PIEN_bm;
 a10:	84 60       	ori	r24, 0x04	; 4
 a12:	18 96       	adiw	r26, 0x08	; 8
 a14:	8c 93       	st	X, r24

	/* If free space in buffer. */
	if (twi->bytesReceived < TWIS_RECEIVE_BUFFER_SIZE) {
 a16:	84 89       	ldd	r24, Z+20	; 0x14
 a18:	88 30       	cpi	r24, 0x08	; 8
 a1a:	08 f5       	brcc	.+66     	; 0xa5e <TWI_SlaveReadHandler+0x5e>
 a1c:	ef 01       	movw	r28, r30
		/* Fetch data */
		uint8_t data = twi->interface->SLAVE.DATA;
 a1e:	01 90       	ld	r0, Z+
 a20:	f0 81       	ld	r31, Z
 a22:	e0 2d       	mov	r30, r0
 a24:	84 85       	ldd	r24, Z+12	; 0x0c
		twi->receivedData[twi->bytesReceived] = data;
 a26:	9c 89       	ldd	r25, Y+20	; 0x14
 a28:	fe 01       	movw	r30, r28
 a2a:	e9 0f       	add	r30, r25
 a2c:	f1 1d       	adc	r31, r1
 a2e:	84 83       	std	Z+4, r24	; 0x04

		/* Process data. */
		twi->Process_Data();
 a30:	ea 81       	ldd	r30, Y+2	; 0x02
 a32:	fb 81       	ldd	r31, Y+3	; 0x03
 a34:	09 95       	icall

		twi->bytesReceived++;
 a36:	8c 89       	ldd	r24, Y+20	; 0x14
 a38:	8f 5f       	subi	r24, 0xFF	; 255
 a3a:	8c 8b       	std	Y+20, r24	; 0x14

		/* If application signalling need to abort (error occured),
		 * complete transaction and wait for next START. Otherwise
		 * send ACK and wait for data interrupt.
		 */
		if (twi->abort) {
 a3c:	88 8d       	ldd	r24, Y+24	; 0x18
 a3e:	88 23       	and	r24, r24
 a40:	49 f0       	breq	.+18     	; 0xa54 <TWI_SlaveReadHandler+0x54>
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
 a42:	e8 81       	ld	r30, Y
 a44:	f9 81       	ldd	r31, Y+1	; 0x01
 a46:	82 e0       	ldi	r24, 0x02	; 2
 a48:	81 87       	std	Z+9, r24	; 0x09
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 a4a:	86 e0       	ldi	r24, 0x06	; 6
 a4c:	8f 8b       	std	Y+23, r24	; 0x17
	twi->status = TWIS_STATUS_READY;
 a4e:	1e 8a       	std	Y+22, r1	; 0x16
		 * send ACK and wait for data interrupt.
		 */
		if (twi->abort) {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
			twi->abort = false;
 a50:	18 8e       	std	Y+24, r1	; 0x18
 a52:	0d c0       	rjmp	.+26     	; 0xa6e <TWI_SlaveReadHandler+0x6e>
		} else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
 a54:	e8 81       	ld	r30, Y
 a56:	f9 81       	ldd	r31, Y+1	; 0x01
 a58:	83 e0       	ldi	r24, 0x03	; 3
 a5a:	81 87       	std	Z+9, r24	; 0x09
 a5c:	08 c0       	rjmp	.+16     	; 0xa6e <TWI_SlaveReadHandler+0x6e>
	}
	/* If buffer overflow, send NACK and wait for next START. Set
	 * result buffer overflow.
	 */
	else {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
 a5e:	a0 81       	ld	r26, Z
 a60:	b1 81       	ldd	r27, Z+1	; 0x01
 a62:	86 e0       	ldi	r24, 0x06	; 6
 a64:	19 96       	adiw	r26, 0x09	; 9
 a66:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 a68:	82 e0       	ldi	r24, 0x02	; 2
 a6a:	87 8b       	std	Z+23, r24	; 0x17
	twi->status = TWIS_STATUS_READY;
 a6c:	16 8a       	std	Z+22, r1	; 0x16
	else {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
		                              TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
	}
}
 a6e:	df 91       	pop	r29
 a70:	cf 91       	pop	r28
 a72:	08 95       	ret

00000a74 <TWI_SlaveWriteHandler>:
 *  Handles TWI slave write transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveWriteHandler(TWI_Slave_t *twi)
{
 a74:	fc 01       	movw	r30, r24
	/* If NACK, slave write transaction finished. */
	if ((twi->bytesSent > 0) && (twi->interface->SLAVE.STATUS &
 a76:	85 89       	ldd	r24, Z+21	; 0x15
 a78:	88 23       	and	r24, r24
 a7a:	71 f0       	breq	.+28     	; 0xa98 <TWI_SlaveWriteHandler+0x24>
 a7c:	a0 81       	ld	r26, Z
 a7e:	b1 81       	ldd	r27, Z+1	; 0x01
 a80:	1a 96       	adiw	r26, 0x0a	; 10
 a82:	8c 91       	ld	r24, X
 a84:	1a 97       	sbiw	r26, 0x0a	; 10
 a86:	84 ff       	sbrs	r24, 4
 a88:	07 c0       	rjmp	.+14     	; 0xa98 <TWI_SlaveWriteHandler+0x24>
	                             TWI_SLAVE_RXACK_bm)) {

		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
 a8a:	82 e0       	ldi	r24, 0x02	; 2
 a8c:	19 96       	adiw	r26, 0x09	; 9
 a8e:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 a90:	81 e0       	ldi	r24, 0x01	; 1
 a92:	87 8b       	std	Z+23, r24	; 0x17
	twi->status = TWIS_STATUS_READY;
 a94:	16 8a       	std	Z+22, r1	; 0x16
 a96:	08 95       	ret
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
	}
	/* If ACK, master expects more data. */
	else {
		if (twi->bytesSent < TWIS_SEND_BUFFER_SIZE) {
 a98:	85 89       	ldd	r24, Z+21	; 0x15
 a9a:	88 30       	cpi	r24, 0x08	; 8
 a9c:	98 f4       	brcc	.+38     	; 0xac4 <TWI_SlaveWriteHandler+0x50>
			uint8_t data = twi->sendData[twi->bytesSent];
 a9e:	85 89       	ldd	r24, Z+21	; 0x15
 aa0:	df 01       	movw	r26, r30
 aa2:	a8 0f       	add	r26, r24
 aa4:	b1 1d       	adc	r27, r1
 aa6:	1c 96       	adiw	r26, 0x0c	; 12
 aa8:	8c 91       	ld	r24, X
			twi->interface->SLAVE.DATA = data;
 aaa:	a0 81       	ld	r26, Z
 aac:	b1 81       	ldd	r27, Z+1	; 0x01
 aae:	1c 96       	adiw	r26, 0x0c	; 12
 ab0:	8c 93       	st	X, r24
			twi->bytesSent++;
 ab2:	85 89       	ldd	r24, Z+21	; 0x15
 ab4:	8f 5f       	subi	r24, 0xFF	; 255
 ab6:	85 8b       	std	Z+21, r24	; 0x15

			/* Send data, wait for data interrupt. */
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
 ab8:	01 90       	ld	r0, Z+
 aba:	f0 81       	ld	r31, Z
 abc:	e0 2d       	mov	r30, r0
 abe:	83 e0       	ldi	r24, 0x03	; 3
 ac0:	81 87       	std	Z+9, r24	; 0x09
 ac2:	08 95       	ret
		}
		/* If buffer overflow. */
		else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
 ac4:	a0 81       	ld	r26, Z
 ac6:	b1 81       	ldd	r27, Z+1	; 0x01
 ac8:	82 e0       	ldi	r24, 0x02	; 2
 aca:	19 96       	adiw	r26, 0x09	; 9
 acc:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 ace:	87 8b       	std	Z+23, r24	; 0x17
	twi->status = TWIS_STATUS_READY;
 ad0:	16 8a       	std	Z+22, r1	; 0x16
 ad2:	08 95       	ret

00000ad4 <TWI_SlaveDataHandler>:
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveDataHandler(TWI_Slave_t *twi)
{
	if (twi->interface->SLAVE.STATUS & TWI_SLAVE_DIR_bm) {
 ad4:	dc 01       	movw	r26, r24
 ad6:	ed 91       	ld	r30, X+
 ad8:	fc 91       	ld	r31, X
 ada:	22 85       	ldd	r18, Z+10	; 0x0a
 adc:	21 ff       	sbrs	r18, 1
 ade:	03 c0       	rjmp	.+6      	; 0xae6 <TWI_SlaveDataHandler+0x12>
		TWI_SlaveWriteHandler(twi);
 ae0:	0e 94 3a 05 	call	0xa74	; 0xa74 <TWI_SlaveWriteHandler>
 ae4:	08 95       	ret
	} else {
		TWI_SlaveReadHandler(twi);
 ae6:	0e 94 00 05 	call	0xa00	; 0xa00 <TWI_SlaveReadHandler>
 aea:	08 95       	ret

00000aec <TWI_SlaveInterruptHandler>:
 *  data transmission, bus error and data collision.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveInterruptHandler(TWI_Slave_t *twi)
{
 aec:	fc 01       	movw	r30, r24
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
 aee:	a0 81       	ld	r26, Z
 af0:	b1 81       	ldd	r27, Z+1	; 0x01
 af2:	1a 96       	adiw	r26, 0x0a	; 10
 af4:	8c 91       	ld	r24, X

	/* If bus error. */
	if (currentStatus & TWI_SLAVE_BUSERR_bm) {
 af6:	82 ff       	sbrs	r24, 2
 af8:	06 c0       	rjmp	.+12     	; 0xb06 <TWI_SlaveInterruptHandler+0x1a>
		twi->bytesReceived = 0;
 afa:	14 8a       	std	Z+20, r1	; 0x14
		twi->bytesSent = 0;
 afc:	15 8a       	std	Z+21, r1	; 0x15
		twi->result = TWIS_RESULT_BUS_ERROR;
 afe:	84 e0       	ldi	r24, 0x04	; 4
 b00:	87 8b       	std	Z+23, r24	; 0x17
		twi->status = TWIS_STATUS_READY;
 b02:	16 8a       	std	Z+22, r1	; 0x16
 b04:	08 95       	ret
	}

	/* If transmit collision. */
	else if (currentStatus & TWI_SLAVE_COLL_bm) {
 b06:	83 ff       	sbrs	r24, 3
 b08:	06 c0       	rjmp	.+12     	; 0xb16 <TWI_SlaveInterruptHandler+0x2a>
		twi->bytesReceived = 0;
 b0a:	14 8a       	std	Z+20, r1	; 0x14
		twi->bytesSent = 0;
 b0c:	15 8a       	std	Z+21, r1	; 0x15
		twi->result = TWIS_RESULT_TRANSMIT_COLLISION;
 b0e:	83 e0       	ldi	r24, 0x03	; 3
 b10:	87 8b       	std	Z+23, r24	; 0x17
		twi->status = TWIS_STATUS_READY;
 b12:	16 8a       	std	Z+22, r1	; 0x16
 b14:	08 95       	ret
 b16:	28 2f       	mov	r18, r24
 b18:	20 74       	andi	r18, 0x40	; 64
	}

	/* If address match. */
	else if ((currentStatus & TWI_SLAVE_APIF_bm) &&
 b1a:	98 2f       	mov	r25, r24
 b1c:	91 74       	andi	r25, 0x41	; 65
 b1e:	91 34       	cpi	r25, 0x41	; 65
 b20:	21 f4       	brne	.+8      	; 0xb2a <TWI_SlaveInterruptHandler+0x3e>
	        (currentStatus & TWI_SLAVE_AP_bm)) {

		TWI_SlaveAddressMatchHandler(twi);
 b22:	cf 01       	movw	r24, r30
 b24:	0e 94 ca 04 	call	0x994	; 0x994 <TWI_SlaveAddressMatchHandler>
 b28:	08 95       	ret
	}

	/* If stop (only enabled through slave read transaction). */
	else if (currentStatus & TWI_SLAVE_APIF_bm) {
 b2a:	22 23       	and	r18, r18
 b2c:	21 f0       	breq	.+8      	; 0xb36 <TWI_SlaveInterruptHandler+0x4a>
		TWI_SlaveStopHandler(twi);
 b2e:	cf 01       	movw	r24, r30
 b30:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <TWI_SlaveStopHandler>
 b34:	08 95       	ret
	}

	/* If data interrupt. */
	else if (currentStatus & TWI_SLAVE_DIF_bm) {
 b36:	88 23       	and	r24, r24
 b38:	24 f4       	brge	.+8      	; 0xb42 <TWI_SlaveInterruptHandler+0x56>
		TWI_SlaveDataHandler(twi);
 b3a:	cf 01       	movw	r24, r30
 b3c:	0e 94 6a 05 	call	0xad4	; 0xad4 <TWI_SlaveDataHandler>
 b40:	08 95       	ret
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 b42:	85 e0       	ldi	r24, 0x05	; 5
 b44:	87 8b       	std	Z+23, r24	; 0x17
	twi->status = TWIS_STATUS_READY;
 b46:	16 8a       	std	Z+22, r1	; 0x16
 b48:	08 95       	ret

00000b4a <vregs_write>:
uint8_t vregs_read(uint32_t address){
	if (address < VREGS_FILE_SIZE){
		return vregs[address];
	}
	else return 0;
}
 b4a:	6f 3f       	cpi	r22, 0xFF	; 255
 b4c:	71 05       	cpc	r23, r1
 b4e:	81 05       	cpc	r24, r1
 b50:	91 05       	cpc	r25, r1
 b52:	09 f0       	breq	.+2      	; 0xb56 <vregs_write+0xc>
 b54:	40 f4       	brcc	.+16     	; 0xb66 <vregs_write+0x1c>
 b56:	fb 01       	movw	r30, r22
 b58:	e1 58       	subi	r30, 0x81	; 129
 b5a:	fe 4d       	sbci	r31, 0xDE	; 222
 b5c:	40 83       	st	Z, r20
 b5e:	60 e0       	ldi	r22, 0x00	; 0
 b60:	70 e0       	ldi	r23, 0x00	; 0
 b62:	cb 01       	movw	r24, r22
 b64:	08 95       	ret
 b66:	61 e0       	ldi	r22, 0x01	; 1
 b68:	70 e0       	ldi	r23, 0x00	; 0
 b6a:	80 e0       	ldi	r24, 0x00	; 0
 b6c:	90 e0       	ldi	r25, 0x00	; 0
 b6e:	08 95       	ret

00000b70 <vregs_read_buffer>:

/**
 * Same as vregs_read, but now read from the buffered vregs
 */
uint8_t vregs_read_buffer(uint32_t address){
	if (address < VREGS_FILE_SIZE){
 b70:	6f 3f       	cpi	r22, 0xFF	; 255
 b72:	71 05       	cpc	r23, r1
 b74:	81 05       	cpc	r24, r1
 b76:	91 05       	cpc	r25, r1
 b78:	09 f0       	breq	.+2      	; 0xb7c <vregs_read_buffer+0xc>
 b7a:	a0 f4       	brcc	.+40     	; 0xba4 <vregs_read_buffer+0x34>
		return vregs_buffer[buffer_selector][address];
 b7c:	e0 91 02 20 	lds	r30, 0x2002	; 0x802002 <buffer_selector>
 b80:	f0 91 03 20 	lds	r31, 0x2003	; 0x802003 <buffer_selector+0x1>
 b84:	45 e0       	ldi	r20, 0x05	; 5
 b86:	51 e0       	ldi	r21, 0x01	; 1
 b88:	e4 9f       	mul	r30, r20
 b8a:	90 01       	movw	r18, r0
 b8c:	e5 9f       	mul	r30, r21
 b8e:	30 0d       	add	r19, r0
 b90:	f4 9f       	mul	r31, r20
 b92:	30 0d       	add	r19, r0
 b94:	11 24       	eor	r1, r1
 b96:	26 58       	subi	r18, 0x86	; 134
 b98:	3f 4d       	sbci	r19, 0xDF	; 223
 b9a:	f9 01       	movw	r30, r18
 b9c:	e6 0f       	add	r30, r22
 b9e:	f7 1f       	adc	r31, r23
 ba0:	80 81       	ld	r24, Z
 ba2:	08 95       	ret
	}
	else return 0;
 ba4:	80 e0       	ldi	r24, 0x00	; 0
}
 ba6:	08 95       	ret

00000ba8 <vregs_writeout>:
 */
int32_t vregs_writeout(){
	int32_t cursor;

	for(cursor = 0; cursor < VREGS_FILE_TOTAL_SIZE; cursor++){
		vregs_buffer[!buffer_selector][cursor] = vregs[cursor];
 ba8:	81 e0       	ldi	r24, 0x01	; 1
 baa:	40 91 02 20 	lds	r20, 0x2002	; 0x802002 <buffer_selector>
 bae:	50 91 03 20 	lds	r21, 0x2003	; 0x802003 <buffer_selector+0x1>
 bb2:	60 91 04 20 	lds	r22, 0x2004	; 0x802004 <buffer_selector+0x2>
 bb6:	70 91 05 20 	lds	r23, 0x2005	; 0x802005 <buffer_selector+0x3>
 bba:	45 2b       	or	r20, r21
 bbc:	46 2b       	or	r20, r22
 bbe:	47 2b       	or	r20, r23
 bc0:	09 f0       	breq	.+2      	; 0xbc4 <vregs_writeout+0x1c>
 bc2:	80 e0       	ldi	r24, 0x00	; 0
 bc4:	ef e7       	ldi	r30, 0x7F	; 127
 bc6:	f1 e2       	ldi	r31, 0x21	; 33
 bc8:	90 e0       	ldi	r25, 0x00	; 0
 bca:	25 e0       	ldi	r18, 0x05	; 5
 bcc:	31 e0       	ldi	r19, 0x01	; 1
 bce:	82 9f       	mul	r24, r18
 bd0:	d0 01       	movw	r26, r0
 bd2:	83 9f       	mul	r24, r19
 bd4:	b0 0d       	add	r27, r0
 bd6:	92 9f       	mul	r25, r18
 bd8:	b0 0d       	add	r27, r0
 bda:	11 24       	eor	r1, r1
 bdc:	a6 58       	subi	r26, 0x86	; 134
 bde:	bf 4d       	sbci	r27, 0xDF	; 223
 be0:	24 e8       	ldi	r18, 0x84	; 132
 be2:	32 e2       	ldi	r19, 0x22	; 34
 be4:	81 91       	ld	r24, Z+
 be6:	8d 93       	st	X+, r24
 * and UART1
 */
int32_t vregs_writeout(){
	int32_t cursor;

	for(cursor = 0; cursor < VREGS_FILE_TOTAL_SIZE; cursor++){
 be8:	e2 17       	cp	r30, r18
 bea:	f3 07       	cpc	r31, r19
 bec:	d9 f7       	brne	.-10     	; 0xbe4 <vregs_writeout+0x3c>
	}

	/**
	 * BEGIN critical section
	 */
	cli();
 bee:	f8 94       	cli

	buffer_selector = !buffer_selector;
 bf0:	81 e0       	ldi	r24, 0x01	; 1
 bf2:	90 e0       	ldi	r25, 0x00	; 0
 bf4:	a0 e0       	ldi	r26, 0x00	; 0
 bf6:	b0 e0       	ldi	r27, 0x00	; 0
 bf8:	40 91 02 20 	lds	r20, 0x2002	; 0x802002 <buffer_selector>
 bfc:	50 91 03 20 	lds	r21, 0x2003	; 0x802003 <buffer_selector+0x1>
 c00:	60 91 04 20 	lds	r22, 0x2004	; 0x802004 <buffer_selector+0x2>
 c04:	70 91 05 20 	lds	r23, 0x2005	; 0x802005 <buffer_selector+0x3>
 c08:	45 2b       	or	r20, r21
 c0a:	46 2b       	or	r20, r22
 c0c:	47 2b       	or	r20, r23
 c0e:	19 f0       	breq	.+6      	; 0xc16 <vregs_writeout+0x6e>
 c10:	80 e0       	ldi	r24, 0x00	; 0
 c12:	90 e0       	ldi	r25, 0x00	; 0
 c14:	dc 01       	movw	r26, r24
 c16:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <buffer_selector>
 c1a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <buffer_selector+0x1>
 c1e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <buffer_selector+0x2>
 c22:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <buffer_selector+0x3>

	sei();
 c26:	78 94       	sei
	/**
	 * END critical section
	 */

	return 0;
}
 c28:	60 e0       	ldi	r22, 0x00	; 0
 c2a:	70 e0       	ldi	r23, 0x00	; 0
 c2c:	cb 01       	movw	r24, r22
 c2e:	08 95       	ret

00000c30 <vregs_init>:
static int32_t buffer_selector = 0;

/**
 * Initialise the virtual registers. Set all fields to their default values.
 */
void vregs_init(){
 c30:	ef e7       	ldi	r30, 0x7F	; 127
 c32:	f1 e2       	ldi	r31, 0x21	; 33
 c34:	84 e8       	ldi	r24, 0x84	; 132
 c36:	92 e2       	ldi	r25, 0x22	; 34
	int32_t cursor;

	/* set everything to zero */
	for(cursor = 0; cursor < VREGS_FILE_TOTAL_SIZE; cursor++){
		vregs[cursor] = 0;
 c38:	11 92       	st	Z+, r1
 */
void vregs_init(){
	int32_t cursor;

	/* set everything to zero */
	for(cursor = 0; cursor < VREGS_FILE_TOTAL_SIZE; cursor++){
 c3a:	e8 17       	cp	r30, r24
 c3c:	f9 07       	cpc	r31, r25
 c3e:	e1 f7       	brne	.-8      	; 0xc38 <vregs_init+0x8>
		vregs[cursor] = 0;
	}

	vregs[VREGS_ZEBROBUS_VERSION] = ZEBROBUS_VERSION;
 c40:	ef e7       	ldi	r30, 0x7F	; 127
 c42:	f1 e2       	ldi	r31, 0x21	; 33
 c44:	80 e2       	ldi	r24, 0x20	; 32
 c46:	80 83       	st	Z, r24
	vregs[VREGS_CLASS_ID] = CLASS_ID;
 c48:	11 82       	std	Z+1, r1	; 0x01
	vregs[VREGS_PRODUCT_ID] = PRODUCT_ID;
 c4a:	12 82       	std	Z+2, r1	; 0x02
	vregs[VREGS_PRODUCT_VERSION] = PRODUCT_VERSION;
 c4c:	13 82       	std	Z+3, r1	; 0x03
	vregs[VREGS_SERIAL_ID] = SERIAL_ID;
 c4e:	14 82       	std	Z+4, r1	; 0x04
	vregs[VREGS_SOFTWARE_VERSION] = SOFTWARE_VERSION;
 c50:	15 82       	std	Z+5, r1	; 0x05
	vregs[VREGS_FILE_TOTAL_SIZE - 1] = VREGS_SYNC_4;
 c52:	8b e4       	ldi	r24, 0x4B	; 75
 c54:	80 93 83 22 	sts	0x2283, r24	; 0x802283 <vregs+0x104>
	vregs[VREGS_FILE_TOTAL_SIZE - 2] = VREGS_SYNC_3;
 c58:	8a ee       	ldi	r24, 0xEA	; 234
 c5a:	80 93 82 22 	sts	0x2282, r24	; 0x802282 <vregs+0x103>
	vregs[VREGS_FILE_TOTAL_SIZE - 3] = VREGS_SYNC_2;
 c5e:	82 e1       	ldi	r24, 0x12	; 18
 c60:	80 93 81 22 	sts	0x2281, r24	; 0x802281 <vregs+0x102>
	vregs[VREGS_FILE_TOTAL_SIZE - 4] = VREGS_SYNC_1;
 c64:	85 e4       	ldi	r24, 0x45	; 69
 c66:	80 93 80 22 	sts	0x2280, r24	; 0x802280 <vregs+0x101>
	vregs[VREGS_FILE_TOTAL_SIZE - 5] = VREGS_SYNC_0;
 c6a:	8f ef       	ldi	r24, 0xFF	; 255
 c6c:	80 93 7f 22 	sts	0x227F, r24	; 0x80227f <vregs+0x100>

	/* also initialise the buffers */
	vregs_writeout();
 c70:	0e 94 d4 05 	call	0xba8	; 0xba8 <vregs_writeout>
 c74:	08 95       	ret

00000c76 <zebro_alert_init>:
//ZebroBus alerts
void zebro_alert_init(void)
{
//	PORTC.DIRSET |= PIN7_bm;
//	PORTC.OUTSET |= ~PIN7_bm;
	PORTA.DIRSET |= PIN0_bm;
 c76:	e0 e0       	ldi	r30, 0x00	; 0
 c78:	f6 e0       	ldi	r31, 0x06	; 6
 c7a:	81 81       	ldd	r24, Z+1	; 0x01
 c7c:	81 60       	ori	r24, 0x01	; 1
 c7e:	81 83       	std	Z+1, r24	; 0x01
	PORTA.OUTSET |= ~PIN0_bm;
 c80:	85 81       	ldd	r24, Z+5	; 0x05
 c82:	8e 6f       	ori	r24, 0xFE	; 254
 c84:	85 83       	std	Z+5, r24	; 0x05
 c86:	08 95       	ret

00000c88 <_exit>:
 c88:	f8 94       	cli

00000c8a <__stop_program>:
 c8a:	ff cf       	rjmp	.-2      	; 0xc8a <__stop_program>
